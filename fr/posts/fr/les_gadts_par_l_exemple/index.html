<!doctype html><html lang=fr><head><title>Les GADTs Par l&#39;Exemple :: Terrain de jeu de stefshine ‚Äî Recueil de pens√©es d&#39;un aspirant d√©veloppeur fonctionnel</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="Soyez les bienvenu¬∑e¬∑s! Cette session a le dessein de vous pr√©senter un outil de programmation tr√®s puissant. Alors que la plupart des introductions sur le sujet commencent par une pr√©sentation de ses fondements th√©oriques d&amp;rsquo;une mani√®re tr√®s formelle, nous avons choisi de vous le pr√©senter √† travers de courts exemples et des cas d&amp;rsquo;utilisation concrets.
Cet atelier est compos√© de trois parties. La derni√®re pr√©sente trois des cas d&amp;rsquo;utilisation des plus utiles."><meta name=keywords content="GADT,GADTs,Generalized Algebraic Data Types,ADT,Algebraic Data Types,Functional Programming,Interface,Free Monad"><meta name=robots content=noodp><link rel=canonical href=https://stankoua.github.io/fr/posts/fr/les_gadts_par_l_exemple/><link rel=stylesheet href=https://stankoua.github.io/assets/style.css><link rel=stylesheet href=https://stankoua.github.io/assets/blue.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://stankoua.github.io/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://stankoua.github.io/img/favicon/blue.png><meta name=twitter:card content=summary><meta name=twitter:title content="Les GADTs Par l'Exemple :: Terrain de jeu de stefshine ‚Äî Recueil de pens√©es d'un aspirant d√©veloppeur fonctionnel"><meta name=twitter:description content="Soyez les bienvenu¬∑e¬∑s! Cette session a le dessein de vous pr√©senter un outil de programmation tr√®s puissant. Alors que la plupart des introductions sur le sujet commencent par une pr√©sentation de ses fondements th√©oriques d&amp;rsquo;une mani√®re tr√®s formelle, nous avons choisi de vous le pr√©senter √† travers de courts exemples et des cas d&amp;rsquo;utilisation concrets.
Cet atelier est compos√© de trois parties. La derni√®re pr√©sente trois des cas d&amp;rsquo;utilisation des plus utiles."><meta name=twitter:site content=https://stankoua.github.io/><meta name=twitter:creator content><meta name=twitter:image content><meta property=og:locale content=fr><meta property=og:type content=article><meta property=og:title content="Les GADTs Par l'Exemple :: Terrain de jeu de stefshine ‚Äî Recueil de pens√©es d'un aspirant d√©veloppeur fonctionnel"><meta property=og:description content="Soyez les bienvenu¬∑e¬∑s! Cette session a le dessein de vous pr√©senter un outil de programmation tr√®s puissant. Alors que la plupart des introductions sur le sujet commencent par une pr√©sentation de ses fondements th√©oriques d&amp;rsquo;une mani√®re tr√®s formelle, nous avons choisi de vous le pr√©senter √† travers de courts exemples et des cas d&amp;rsquo;utilisation concrets.
Cet atelier est compos√© de trois parties. La derni√®re pr√©sente trois des cas d&amp;rsquo;utilisation des plus utiles."><meta property=og:url content=https://stankoua.github.io/fr/posts/fr/les_gadts_par_l_exemple/><meta property=og:site_name content="Les GADTs Par l'Exemple"><meta property=og:image content><meta property=og:image:width content=2048><meta property=og:image:height content=1024><meta property=article:published_time content="2019-10-27 22:30:00 &#43;0200 &#43;0200"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/fr><div class=logo>Stefshine&#39;s playground</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/fr/fr/about>A propos de moi</a></li><li><a href=/fr/fr/conference-work>Conf√©rences</a></li><div class=spacer></div><ul class=language-selector><ul class=language-selector-current><li>Fran√ßais ‚ñæ</li></ul><ul class="language-selector__more hidden"><li><a href=https://stankoua.github.io/fr/>Fran√ßais</a></li><li><a href=https://stankoua.github.io/>English</a></li></ul></ul></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/fr/fr/about>A propos de moi</a></li><li><a href=/fr/fr/conference-work>Conf√©rences</a></li><hr><li><a href=https://stankoua.github.io/fr/>Fran√ßais</a></li><li><a href=https://stankoua.github.io/>English</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://stankoua.github.io/fr/posts/fr/les_gadts_par_l_exemple/>Les GADTs Par l&rsquo;Exemple</a></h1><div class=post-meta><span class=post-date>2019-10-27</span></div><div class=post-content><p>Soyez les bienvenu¬∑e¬∑s! Cette session a le dessein de vous pr√©senter
un outil de programmation tr√®s puissant. Alors que la plupart des
introductions sur le sujet commencent par une pr√©sentation de ses
fondements th√©oriques d&rsquo;une mani√®re tr√®s formelle, nous avons choisi
de vous le pr√©senter √† travers de courts exemples et des cas
d&rsquo;utilisation concrets.</p><p>Cet atelier est compos√© de trois parties. La derni√®re pr√©sente trois
des cas d&rsquo;utilisation des plus utiles. Ils forment les usages majeurs
en pratique. Mais ne vous y aventurez pas sans pr√©paration! Cette partie
est la derni√®re pour une bonne raison: elle s&rsquo;appuie massivement sur
les le√ßons des parties pr√©c√©dentes.
Commencez par <a href=#premier-contact>Premier Contact</a>, elle vous exposera,
via les plus simples exemples, les id√©es clefs. Son but est
d&rsquo;ouvrir votre esprit √† des mani√®res d&rsquo;utiliser les types et donn√©es
que vous n&rsquo;avez vraisemblablement jamais soup√ßonn√©es.
Arpentez ensuite
<a href=#cas-d-utilisation-simples-et-utiles-relations-sur-les-types>Cas d‚Äôutilisation simples et utiles: relations sur les types</a>,
pour un premier d√©fi devant un usage pratique.
Apr√®s cela seulement vous serez pr√™t¬∑e pour
<a href=#cas-d-utilisation-plus-avanc%C3%A9s>Cas d‚ÄôUtilisation Plus Avanc√©s</a>.</p><p>Assurez vous de <strong>lire <a href=#lisez-moi>LISEZ-MOI</a></strong>, cette section contient de pr√©cieuses
astuces pour faciliter votre parcours.</p><h2 id=remerciements>Remerciements</h2><p>Nous tenons √† remercier <a href=http://www.laure-juglaret.fr/>Laure Juglaret</a> pour
ses nombreuses relectures, ses pr√©cieuses remarques et corrections.</p><h2 id=lisez-moi>LISEZ-MOI</h2><p>Durant toute cette pr√©sentation, nous consid√©rerons que:</p><ul><li><code>null</code> <strong>n&rsquo;existe pas!</strong></li><li><strong>La r√©flexion au runtime n&rsquo;existe pas!</strong> (c.-√†-d. <code>isInstanceOf</code>, <code>getClass</code>, etc)</li></ul><p>Cette pr√©sentation consid√®re que <em>ces fonctionnalit√©s n&rsquo;existent pas du tout!</em>.</p><p><strong>Leur utilisation n&rsquo;am√®nera jamais √† une r√©ponse correcte aux questions.</strong>.</p><p>Pour faire cet atelier vous devez disposez du n√©cessaire pour √©crire, compiler et
ex√©cuter rapidement du code <em>Scala</em>. Le meilleur moyen est d&rsquo;ouvrir une session
interactive (<em>R.E.P.L.</em>). Si vous avez <em>Scala</em> d&rsquo;install√© sur votre syst√®me, vous
pouvez facilement en d√©marrer une via la ligne de commande en ex√©cutant le programme
<code>scala</code>:</p><pre><code class=language-scala>system-command-line# scala
Welcome to Scala 2.13.1 (OpenJDK 64-Bit Server VM, Java 1.8.0_222).
Type in expressions for evaluation. Or try :help.

scala&gt;
</code></pre><p>Pour rappel, dans une session interactive (<em>R.E.P.L.</em>),
la commande <code>:paste</code> permet de copier du code dans la session
et la commande <code>:reset</code> de repartir d&rsquo;un environnement vierge.</p><p>Si vous n&rsquo;avez pas <em>Scala</em> d&rsquo;install√©, <strong>vous pouvez utiliser</strong> le
site <a href=https://scastie.scala-lang.org/>https://scastie.scala-lang.org/</a> .</p><h2 id=√©chauffements>√âchauffements</h2><p>Cette section est un bref rappel de quelques d√©finitions et propri√©t√©s sur
les types et les valeurs.</p><h3 id=valeurs-et-types><em>Valeurs</em> et <em>Types</em>?</h3><p>Les <strong>valeurs</strong> sont les <em>donn√©es concr√®tes que vos programmes manipulent</em>
comme l&rsquo;entier <code>5</code>, le bool√©en <code>true</code>, la cha√Æne <code>&quot;Hello World!&quot;</code>,
la fonction <code>(x: Double) =&gt; x / 7.5</code>, la liste <code>List(1,2,3)</code>, etc.
Il est souvent pratique de classer les valeurs en groupes. Ces groupes sont appel√©s
des <strong>types</strong>. Par exemple:</p><ul><li><code>Int</code> est le groupe des valeurs enti√®res, c.-√†-d. les valeurs telles que <code>1</code>, <code>-7</code>, <code>19</code>, etc.</li><li><code>Boolean</code> est le groupe contenant exactement les valeurs
<code>true</code> et <code>false</code> (ni plus, ni moins!).</li><li><code>String</code> est le groupe dont les valeurs sont <code>&quot;Hello World!&quot;</code>, <code>&quot;&quot;</code>, <code>&quot;J' ‚ù§Ô∏è les GADTs&quot;</code>, etc.</li><li><code>Double =&gt; Double</code> est le groupe dont les valeurs sont les fonctions prenant en argument
n&rsquo;importe quel <code>Double</code> et renvoyant √©galement un double <code>Double</code>.</li></ul><p>Pour indiquer que la valeur <code>v</code> appartient au type (c.-√†-d. groupe de valeurs) <code>T</code>,
la notation est <code>v : T</code>. En <em>Scala</em>, tester si une valeur <code>v</code> appartient au type <code>T</code>
est tr√®s simple: il suffit de taper <code>v : T</code> dans la session interactive (<em>REPL</em>):</p><pre><code class=language-scala>scala&gt; 5 : Int
res7: Int = 5
</code></pre><p>Si <em>Scala</em> l&rsquo;accepte, alors <code>v</code> appartient bien au type <code>T</code>. Si <em>Scala</em> r√¢le,
ce n&rsquo;est probablement pas le cas:</p><pre><code class=language-scala>scala&gt; 5 : String
       ^
       error: type mismatch;
        found   : Int(5)
        required: String
</code></pre><h3 id=combien-de-types>Combien de types?</h3><p>Cr√©ons maintenant quelques types et quelques unes de leurs valeurs (quand cela est possible!).</p><pre><code class=language-scala>class UnType
</code></pre><ul><li><p><strong>Question 1:</strong> Combien de types la ligne <code>class UnType</code> d√©finit-elle?</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><p>Comme son nom le sugg√®re, la ligne <code>class UnType</code> d√©finit seulement un type, nomm√© <code>UnType</code>.</p><p></details></p></li></ul><p>Passons maintenant √†:</p><pre><code class=language-scala>class UnTypePourChaque[A]
</code></pre><ul><li><p><strong>Question 2:</strong> Combien de types la ligne <code>class UnTypePourChaque[A]</code> d√©finit-elle?</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><p>Comme son nom le sugg√®re, chaque type concret <code>A</code> donne lieu √†
un type distinct <code>UnTypePourChaque[A]</code>.</p><p>Par exemple, une liste d&rsquo;entiers n&rsquo;est ni une liste de bool√©ens,
ni une liste de cha√Æne de caract√®res, ni une liste de fonctions, ni &hellip;
En effet les types <code>List[Int]</code>, <code>List[Boolean]</code>,
<code>List[Int =&gt; Int]</code>, etc sont tous des types distincts.</p><p>la ligne <code>class UnTypePourChaque[A]</code> d√©finit
<strong>un type distinct pour chaque type concret</strong> <code>A</code>.
Il y a une infinit√© de types concrets <code>A</code>,
donc une infinit√© de de types distincts <code>UnTypePourChaque[A]</code>.</p><p></details></p></li><li><p><strong>Question 3:</strong> Donnez une valeur qui appartient √† la fois aux types
<code>UnTypePourChaque[Int]</code> et <code>UnTypePourChaque[Boolean]</code>.</p><p><strong>Pour rappel, <code>null</code> n&rsquo;existe pas!</strong></p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><p>C&rsquo;est en fait impossible. Chaque type concret <code>A</code> donne lieu
√† un type distinct <code>UnTypePourChaque[A]</code> qui n&rsquo;a aucune valeur en commun
avec les autres types de la forme <code>UnTypePourChaque[B]</code> avec <code>B ‚â† A</code>.</p><p></details></p></li></ul><h3 id=combien-de-valeurs>Combien de valeurs?</h3><p>En consid√©rant le type suivant:</p><pre><code class=language-scala>final abstract class PasDeValeurPourCeType
</code></pre><ul><li><p><strong>Question 1:</strong> Donnez une valeur appartenant au type <code>PasDeValeurPourCeType</code>?
Combien de valeurs appartiennent au type <code>PasDeValeurPourCeType</code>?</p><p><details><summary><em>Astuce (cliquer pour d√©voiler)</em></summary></p><ul><li>Qu&rsquo;est ce qu&rsquo;une classe <code>final</code>? En quoi est-ce qu&rsquo;elle diff√®re d&rsquo;une classe normale (non finale)?</li><li>Qu&rsquo;est ce qu&rsquo;une classe <code>abstract</code>? En quoi est-ce qu&rsquo;elle diff√®re d&rsquo;une classe concr√®te?</li></ul><p></details></p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><p>La classe <code>PasDeValeurPourCeType</code> est d√©clar√©e comme <code>abstract</code>.
Cela signifie qu&rsquo;il est interdit de cr√©er des instances directes de cette classe:</p><pre><code class=language-scala>scala&gt; new PasDeValeurPourCeType
       ^
       error: class PasDeValeurPourCeType is abstract; cannot be instantiated
</code></pre></li></ul><p>La seule mani√®re de cr√©er une instance d&rsquo;une classe abstraite est de cr√©er une
une sous-classe concr√®te. Mais le mot clef <code>final</code> interdit la cr√©ation de
telles sous-classes:</p><pre><code>```scala
scala&gt; class SousClasseConcrete extends PasDeValeurPourCeType
                                        ^
        error: illegal inheritance from final class PasDeValeurPourCeType
```

Il n'existe aucun moyen de cr√©er une instance pour `PasDeValeurPourCeType`.

&lt;/details&gt;
</code></pre><p>Prenons un autre exemple:</p><pre><code class=language-scala>sealed trait ExactementUneValeur
case object LaSeuleValeur extends ExactementUneValeur
</code></pre><ul><li><p><strong>Question 2:</strong> Donnez une valeur appartenant au type <code>ExactementUneValeur</code>?</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><p>Par d√©finition, <code>LaSeuleValeur</code> est une valeur du type <code>ExactementUneValeur</code>.</p><p></details></p></li><li><p><strong>Question 3:</strong> Combien de valeurs appartiennent √† <code>ExactementUneValeur</code>?</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><p>Comme ci-dessus, <code>ExactementUneValeur</code>, √©tant un <code>trait</code>, est <em>abstrait</em>. √âtant <code>sealed</code>,
l&rsquo;√©tendre en dehors de son fichier source est interdit.
Donc <code>LaSeuleValeur</code> est la seule valeur du type <code>ExactementUneValeur</code>.</p><p></details></p></li></ul><h2 id=premier-contact>Premier Contact</h2><p>Cette partie pr√©sente les id√©es clefs. Il y a en fait seulement
deux id√©es! Vous trouverez ici des exemples √©pur√©s illustrant chacune
de ces deux id√©es.</p><h3 id=cas-d-utilisation-preuve-d-une-propri√©t√©>Cas d&rsquo;Utilisation: Preuve d&rsquo;une propri√©t√©</h3><p>D√©finissons un simple <em>sealed trait</em>:</p><pre><code class=language-scala>sealed trait ATrait[A]
case object AValue extends ATrait[Char]
</code></pre><ul><li><p><strong>Question 1:</strong> Donnez une valeur du type <code>ATrait[Char]</code>.</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><p>Par d√©finition, <code>AValue</code> est une valeur du type <code>ATrait[Char]</code>.</p><p></details></p></li><li><p><strong>Question 2:</strong> Donnez une valeur du type <code>ATrait[Double]</code>.</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><p>Il n&rsquo;existe aucun moyen d&rsquo;obtenir une instance du type <code>ATrait[Double]</code>.
Il n&rsquo;existe en fait aucun moyen d&rsquo;obtenir une instance de <code>ATrait[B]</code> pour <code>B ‚â† Char</code>
parce que la seule valeur possible est <code>AValue</code> qui est de type <code>ATrait[Char]</code>.</p><p></details></p></li><li><p><strong>Question 3:</strong> Que pouvez vous conclure sur le type <code>A</code> si vous avez une valeur
<code>ev</code> de type <code>ATrait[A]</code> (c.-√†-d. <code>ev: ATrait[A]</code>)?</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><p>La seule valeur possible est <code>AValue</code>, donc <code>ev == AValue</code>.
De plus <code>AValue</code> est de type <code>ATrait[Char]</code> donc <code>A = Char</code>.</p><p></details></p></li><li><p><strong>Question 4:</strong> Dans la session interactive (<em>REPL</em>), entrez le code suivant:</p><pre><code class=language-scala>def f[A](x: A, ev: ATrait[A]): Char =
  x
</code></pre></li><li><p><strong>Question 5:</strong> Essayez maintenant en utilisant un filtrage par motif
(pattern matching) sur <code>ev: ATrait[A]</code></p><pre><code class=language-scala>def f[A](x: A, ev: ATrait[A]): Char =
  ev match {
    case AValue =&gt; x
  }
</code></pre><p>Le filtrage par motif (pattern-matching) est il exhaustif?</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><p>Le filtrage par motif est exhaustif parce la seule et unique valeur possible
pour <code>ev</code> est en fait <code>AValue</code>. De plus <code>AValue</code> est de type <code>ATrait[Char]</code> ce qui signifie
que <code>ev : ATrait[Char]</code> parce que <code>ev == AValue</code>. Donc <code>A = Char</code> et <code>x : Char</code>.</p><p></details></p></li><li><p><strong>Question 6:</strong> Appelez <code>f</code> avec <code>x = 'w' : Char</code>.</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><pre><code class=language-scala>scala&gt; f[Char]('w', AValue)
res0: Char = w
</code></pre><p></details></p></li><li><p><strong>Question 7:</strong> Appelez <code>f</code> avec <code>x = 5.2 : Double</code>.</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><p>C&rsquo;est impossible parce que cela demenderait de fournir une valeur
<code>ev : ATrait[Double]</code>, ce qui n&rsquo;existe pas!</p><pre><code class=language-scala>scala&gt; f[Double](5, AValue)
                    ^
          error: type mismatch;
            found   : AValue.type
            required: ATrait[Double]
</code></pre><p></details></p></li></ul><p><details><summary><strong>Remarque pour les personnes √† l&rsquo;aise en <em>Scala</em></strong> <em>(cliquer pour d√©voiler)</em></summary></p><p>En utilisant toutes les chouettes fonctionnalit√©s syntaxiques de <em>Scala</em>,
la version satisfaisante en production du code ci-dessus est:</p><pre><code class=language-scala>sealed trait IsChar[A]
object IsChar {
  implicit case object Evidence extends IsChar[Char]

  def apply[A](implicit evidence: IsChar[A]): IsChar[A] =
    evidence
}

def f[A: IsChar](x: A): Char =
  IsChar[A] match {
    case IsChar.Evidence =&gt; x
  }
</code></pre><p></details></p><h3 id=cas-d-utilisation-la-seule-chose-que-je-sais-est-qu-il-existe>Cas d&rsquo;Utilisation: La seule chose que je sais, est qu&rsquo;il existe</h3><p>Que feriez vous si vous vouliez que votre application tienne un journal d‚Äô√©v√®nements (c.-√†-d. un <em>log</em>),
mais que vous vouliez √™tre sur qu&rsquo;elle ne d√©pende d&rsquo;aucun d√©tail d&rsquo;impl√©mentation de la m√©thode
de journalisation (c.-√†-d. du <em>logger</em>), de telle mani√®re que vous puissiez changer son impl√©mentation
sans risquer de casser votre application?</p><p>En consid√©rant le type suivant, <code>UnknownLogger</code>, des m√©thodes de journalisation:</p><pre><code class=language-scala>sealed trait UnknownLogger
final case class LogWith[X](logs : X, appendMessage: (X, String) =&gt; X) extends UnknownLogger
</code></pre><p>La premi√®re m√©thode (c.-√†-d. *<em>logger</em>) que nous cr√©ons stocke les messages dans une <code>String</code>:</p><pre><code class=language-scala>val loggerStr : UnknownLogger =
  LogWith[String](&quot;&quot;, (logs: String, message: String) =&gt; logs ++ message)
</code></pre><p>La seconde m√©thode les stocke dans une <code>List[String]</code>:</p><pre><code class=language-scala>val loggerList : UnknownLogger =
  LogWith[List[String]](Nil, (logs: List[String], message: String) =&gt; message :: logs)
</code></pre><p>La troisi√®me m√©thode de journalisation imprime directement les messages sur la sortie standard:</p><pre><code class=language-scala>val loggerStdout : UnknownLogger =
  LogWith[Unit]((), (logs: Unit, message: String) =&gt; println(message))
</code></pre><p>Notez que ces trois m√©thodes de journalisation ont toutes le m√™me type
(c.-√†-d. <code>UnknownLogger</code>) mais qu&rsquo;elles stockent les messages en utilisant
diff√©rents types <code>X</code> (<code>String</code>, <code>List[String]</code> et <code>Unit</code>).</p><ul><li><p><strong>Question 1:</strong> Soit <code>v</code> une valeur de type <code>UnknownLogger</code>.
Clairement <code>v</code> doit √™tre une instance de la classe <code>LogWith[X]</code> pour un certain <code>X</code>.
Que pouvez vous dire sur le type <code>X</code>? Pouvez-vous deviner quel type concret est <code>X</code>?</p><p><strong>Pour rappel, il est interdit d&rsquo;utiliser la r√©flexion au runtime!</strong> (c.-√†-d. <code>isInstanceOf</code>, <code>getClass</code>, etc)</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><p>Nous ne savons presque rien sur <code>X</code>. La seule chose que nous avons est qu&rsquo;il existe au
moins une valeur (<code>v.logs</code>) de type <code>X</code>. √Ä part cela, <code>X</code> peut √™tre n&rsquo;importe quel type.</p><p>Ne pas savoir quel type concret est <code>X</code> est tr√®s utile pour garantir que le code qui utilisera
<code>v : UnknownLogger</code> ne d√©pendra pas de la nature de <code>X</code>. Si ce code savait que <code>X</code> √©tait
<code>String</code> par exemple, il pourrait ex√©cuter des op√©rations que nous voulons interdir comme inverser
la liste, ne retenir que les <em>n</em> premiers caract√®res, etc. En cachant la nature de<code>X</code>, nous for√ßons
notre application √† ne pas d√©pendre du type concret derri√®re<code>X</code> mais de n&rsquo;utiliser que la
fonnction fournie <code>v.appendMessage</code>.
Ainsi changer l&rsquo;impl√©mentation r√©elle de la m√©thode de journalisation ne cassera aucun code.</p><p></details></p></li><li><p><strong>Question 2:</strong> √âcrivez la fonction <code>def log(message: String, v: UnknownLogger): UnknownLogger</code>
qui utilise <code>v.appendMessage</code> pour ajouter le <code>message</code> au journal <code>v.logs</code>
et retourne un nouvel <code>UnknownLogger</code> contenant le nouveau journal (c.-√†-d. le nouveau <code>log</code>).</p><p>Pour rappel, en <em>Scala</em>, le motif (c.-√†-d. pattern) <code>case ac : AClass[t] =&gt;</code>
est possible dans les expressions de type <code>match/case</code> comme alternative au motif
<code>case AClass(v) =&gt;</code>:</p><pre><code class=language-scala>final case class AClass[A](value : A)

def f[A](v: AClass[A]): A =
  v match {
    case ac : AClass[t] =&gt;
      // La variable `t` is une variable de type
      // Le type `t` est `A`
      val r : t = ac.value
      r
  }
</code></pre><p>Son principal avantage est d&rsquo;introduire la variable de type <code>t</code>.
Les variables de type se comportent comme des variables de motif classiques
(c.-√†-d. pattern variables) √† l&rsquo;exception pr√©s qu&rsquo;elles repr√©sentent des
types et non des valeurs.
Avoir <code>t</code> sous la main nous permet d&rsquo;aider le compilateur en donnant
explicitement certains types (comme ci-dessus, expliciter que <code>r</code> est de type <code>t</code>).</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><pre><code class=language-scala>def log(message: String, v: UnknownLogger): UnknownLogger =
  v match {
    case vx : LogWith[x] =&gt; LogWith[x](vx.appendMessage(vx.logs, message), vx.appendMessage)
  }
</code></pre><p></details></p></li><li><p><strong>Question 3:</strong> Ex√©cutez <code>log(&quot;Hello World&quot;, loggerStr)</code> et <code>log(&quot;Hello World&quot;, loggerList)</code>
et <code>log(&quot;Hello World&quot;, loggerStdout)</code></p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><pre><code class=language-scala>scala&gt; log(&quot;Hello World&quot;, loggerStr)
res0: UnknownLogger = LogWith(Hello World,$$Lambda$988/1455466014@421ead7e)

scala&gt; log(&quot;Hello World&quot;, loggerList)
res1: UnknownLogger = LogWith(List(Hello World),$$Lambda$989/1705282731@655621fd)

scala&gt; log(&quot;Hello World&quot;, loggerStdout)
Hello World
res2: UnknownLogger = LogWith((),$$Lambda$990/1835105031@340c57e0)
</code></pre><p></details></p></li></ul><p><details><summary><strong>Remarque pour les personnes √† l&rsquo;aise en <em>Scala</em></strong> <em>(cliquer pour d√©voiler)</em></summary></p><p>Une fois encore, en utilisant toutes les chouettes fonctionnalit√©s syntaxiques de <em>Scala</em>,
la version satisfaisante en production du code ci-dessus est:</p><pre><code class=language-scala>sealed trait UnknownLogger {
  type LogsType
  val logs : LogsType
  def appendMessage(presentLogs: LogsType, message: String): LogsType
}

object UnknownLogger {

  final case class LogWith[X](logs : X, appendMessage_ : (X, String) =&gt; X) extends UnknownLogger {
    type LogsType = X
    def appendMessage(presentLogs: LogsType, message: String): LogsType =
      appendMessage_(presentLogs, message)
  }

  def apply[X](logs: X, appendMessage: (X, String) =&gt; X): UnknownLogger =
    LogWith[X](logs, appendMessage)
}
</code></pre><p></details></p><h3 id=conclusion-interm√©diaire>Conclusion Interm√©diaire</h3><p>Les <em>GADTs</em> ne sont en fait que ceci: de simples <em>sealed trait</em> avec quelques
<em>case object</em> (possiblement aucun) et quelques <em>final case class</em> (√©galement possiblement aucune!).
Dans les parties suivantes, nous explorerons quelques un des cas d&rsquo;utilisation
majeurs des <em>GADTs</em>.</p><h2 id=cas-d-utilisation-simples-et-utiles-relations-sur-les-types>Cas d&rsquo;utilisation simples et utiles: relations sur les types</h2><p>Une facult√© simple mais tr√®s utile des <em>GADTs</em> est l&rsquo;expression de relations sur les types telles que:</p><ul><li>Le type <code>A</code> est-il √©gal au type <code>B</code>?</li><li>Le type <code>A</code> est-il un sous-type de <code>B</code>?</li></ul><p>Notez bien que, par d√©finition, tout type <code>A</code> est sous-type de lui-m√™me (c.-√†-d. <code>A &lt;: A</code>),
tout comme tout entier <code>x</code> est √©galement inf√©rieur ou √©gal √† lui-m√™me <code>x ‚â§ x</code>.</p><h3 id=cas-d-utilisation-t√©moin-d-√©galit√©-entre-types>Cas d&rsquo;Utilisation: T√©moin d&rsquo;√âgalit√© entre Types</h3><pre><code class=language-scala>sealed trait EqT[A,B]
final case class Evidence[X]() extends EqT[X,X]
</code></pre><ul><li><p><strong>Question 1:</strong> Donnez une valeur de type <code>EqT[Int, Int]</code></p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><pre><code class=language-scala>scala&gt; Evidence[Int]() : EqT[Int, Int]
res0: EqT[Int,Int] = Evidence()
</code></pre><p></details></p></li><li><p><strong>Question 2:</strong> Donnez une valeur de type <code>EqT[String, Int]</code></p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><p>La classe <code>Evidence</code> est l&rsquo;unique sous-classe conctr√®te du trait <code>EqT</code> et il est
impossible d&rsquo;en cr√©er une autre parce que <code>EqT</code> est <code>sealed</code>. Donc une valeur <code>v : EqT[A,B]</code>
ne peut √™tre qu&rsquo;une instance de <code>Evidence[X]</code> pour un certain type <code>X</code>, qui elle-m√™me est
de type <code>EqT[X,X]</code>.
Ainsi il n&rsquo;y a aucun moyen d&rsquo;obtenir une valeur de type <code>EqT[String, Int]</code></p><p></details></p></li><li><p><strong>Question 3:</strong> Soient <code>A</code> et <code>B</code> deux types (inconnus).
Si je vous donne une valeur de type <code>EqT[A,B]</code>, que pouvez-vous en d√©duire sur <code>A</code> et <code>B</code>?</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><p>Si je vous donne une valeur <code>v : EqT[A,B]</code>, alors vous savez que <code>v</code> est une instance
de <code>Evidence[X]</code> pour un certain type <code>X</code> (inconnu). En effet la classe <code>Evidence</code> est la seule
et unique sous-classe concr√®te du <code>sealed trait</code> <code>EqT</code>. En fait, <code>Evidence[X]</code> est un sous-type de
<code>EqT[X,X]</code>. Donc <code>v : EqT[X,X]</code>. Les types <code>EqT[A,B]</code> et <code>EqT[X,X]</code> n&rsquo;ont aucune valeur en commun
si <code>A ‚â† X</code> ou <code>B ‚â† X</code>, donc <code>A = X</code> et <code>B = X</code>. Et donc <code>A = B</code>. CQFD.</p><p></details></p></li></ul><p><details><summary><strong>Remarque pour les personnes √† l&rsquo;aise en <em>Scala</em></strong> <em>(cliquer pour d√©voiler)</em></summary></p><p>En production, il est pratique de d√©finir <code>EqT</code> de la mani√®re suivante, qui est bien entendu √©quivalente:</p><pre><code class=language-scala>sealed trait EqT[A,B]
object EqT {
  final case class Evidence[X]() extends EqT[X,X]

  implicit def evidence[X] : EqT[X,X] = Evidence[X]()

  def apply[A,B](implicit ev: EqT[A,B]): ev.type = ev
}
</code></pre><p></details></p><h4 id=passer-d-un-type-√©gal-√†-l-autre>Passer d&rsquo;un type √©gal √† l&rsquo;autre</h4><p>Si <code>A</code> et <code>B</code> sont en fait le m√™me type, alors <code>List[A]</code> est √©galement le m√™me
type que <code>List[B]</code>, <code>Option[A]</code> est √©galement le m√™me type que <code>Option[B]</code>,
etc. De mani√®re g√©n√©rale, pour n&rsquo;importe quel <code>F[_]</code>, <code>F[A]</code> est √©galement le m√™me type
que <code>F[B]</code>.</p><ul><li><p><strong>Question 4:</strong> √âcrivez la fonction <code>def coerce[F[_],A,B](eqT: EqT[A,B])(fa: F[A]): F[B]</code>.</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><pre><code class=language-scala>def coerce[F[_],A,B](eqT: EqT[A,B])(fa: F[A]): F[B] =
  eqT match {
    case _ : Evidence[x] =&gt; fa
  }
</code></pre><p></details></p></li></ul><p>La biblioth√®que standard de <em>Scala</em> d√©finit d√©j√† une classe, nomm√©e <code>=:=[A,B]</code>
(son nom est bel et bien <code>=:=</code>), repr√©sentant l&rsquo;√©galit√© entre types.
Je vous recommande vivement de jeter un ≈ìil
<a href=https://www.scala-lang.org/api/current/scala/$eq$colon$eq.html>√† sa documentation (cliquez ici)</a>.
Fort heureusement, pour plus de lisibilit√©, <em>Scala</em> nous permet d&rsquo;√©crire <code>A =:= B</code> le type <code>=:=[A,B]</code>.</p><p>√âtant donn√© deux types <code>A</code> et <code>B</code>, avoir une instance (c.-√†-d. objet)
de <code>A =:= B</code> prouve que <code>A</code> et <code>B</code> sont en r√©alit√© le m√™me type,
tout comme pour <code>EqT[A,B]</code>.
Pour rappel, <code>A =:= B</code> n&rsquo;est que du sucre syntaxique pour d√©signer le type <code>=:=[A,B]</code>.</p><p>Des instances de <code>A =:= B</code> peuvent √™tres cr√©es en utilisant la fonction
<a href="https://www.scala-lang.org/api/current/scala/$less$colon$less$.html#refl[A]:A=:=A"><code>(&lt;:&lt;).refl[X]: X =:= X</code>
(cliquer pour voir la documentation)</a>.
Le &ldquo;symbole&rdquo; <code>&lt;:&lt;</code> est en effet un nom d&rsquo;objet valide.</p><ul><li><p><strong>Question 5:</strong> En utilisant la fonction <code>coerce</code> ci-dessus,
√©crivez la fonction <code>def toScalaEq[A,B](eqT: EqT[A,B]): A =:= B</code>.</p><p><details><summary><em>Astuce (cliquer pour d√©voiler)</em></summary></p><pre><code class=language-scala>def toScalaEq[A,B](eqT: EqT[A,B]): A =:= B = {
  /* Trouver une d√©finition pour:
        - le constructeur de type `F`
        - la valeur `fa : F[A]`
  */
  type F[X] = ???
  val fa : F[A] = ???

  /* Telles que cet appel: */
  coerce[F,A,B](eqT)(fa) // soit de type `F[B]`
}
</code></pre><p></details></p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><pre><code class=language-scala>def toScalaEq[A,B](eqT: EqT[A,B]): A =:= B = {
  type F[X] = A =:= X
  val fa: F[A] = (&lt;:&lt;).refl[A]
  coerce[F,A,B](eqT)(fa)
}
</code></pre><p></details></p></li><li><p><strong>Question 6:</strong> En utilisant la <em>m√©thode</em> <code>substituteCo[F[_]](ff: F[A]): F[B]</code> des
objets de la classe <code>A =:= B</code>, dont la
<a href=https://www.scala-lang.org/api/current/scala/$eq$colon$eq.html#substituteCo[F[_]](ff:F[From]):F[To]>documentation est ici</a>,
√©crivez la fonction <code>def fromScalaEq[A,B](scala: A =:= B): EqT[A,B]</code>.</p><p><details><summary><em>Astuce (cliquer pour d√©voiler)</em></summary></p><pre><code class=language-scala>def fromScalaEq[A,B](scala: A =:= B): EqT[A,B] = {
  /* Trouver une d√©finition pour:
        - le constructeur de type `F`
        - la valeur `fa : F[A]`
  */
  type F[X] = ???
  val fa : F[A] = ???

  /* Telles que cet appel: */
  scala.substituteCo[F](fa) // soit de type `F[B]`
}
</code></pre><p></details></p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><pre><code class=language-scala>def fromScalaEq[A,B](scala: A =:= B): EqT[A,B] = {
  type F[X] = EqT[A,X]
  val fa: F[A] = Evidence[A]()
  scala.substituteCo[F](fa)
}
</code></pre><p></details></p></li></ul><h3 id=cas-d-utilisation-t√©moin-de-sous-typage>Cas d&rsquo;Utilisation: T√©moin de Sous-Typage</h3><p>Dans cette section, nous voulons cr√©er les types <code>SubTypeOf[A,B]</code> dont les valeurs
prouvent que le type <code>A</code> est un sous-type de <code>B</code> (c.-√†-d. <code>A &lt;: B</code>).
Une classe similaire, <em>mais diff√©rente</em>, est d√©j√† d√©finie dans la
biblioth√®que standard de <em>Scala</em>.
Il s&rsquo;agit de la classe <code>&lt;:&lt;[A,B]</code>, qui est le plus souvent √©crite <code>A &lt;:&lt; B</code>. Sa
<a href=https://www.scala-lang.org/api/current/scala/$less$colon$less.html>documentation est ici</a>.
Cette section √©tant d√©di√©e √† l&rsquo;impl√©mentation d&rsquo;une variante de cette classe,
veuillez <strong>ne pas utiliser</strong> <code>&lt;:&lt;[A,B]</code> pour impl√©menter <code>SubTypeOf</code>.</p><ul><li><p><strong>Question 1:</strong> En utilisant uniquement des <em>bornes sup√©rieures</em> (c.-√†-d. <code>A &lt;: B</code>)
ou <em>bornes inf√©rieures</em> (c.-√†-d. <code>A &gt;: B</code>) et <strong>aucune</strong> <em>annotation de variance</em>
(c.-√†-d. <code>[+A]</code> et <code>[-A]</code>),
cr√©ez le trait <code>SubTypeOf[A,B]</code> (et tout ce qui est n√©cessaire) tel que:</p><blockquote><p>Il existe une valeur de type <code>SubType[A,B]</code> <strong>si et seulement si</strong>
<code>A</code> est un sous-type de <code>B</code> (c.-√†-d. <code>A &lt;: B</code>).</p></blockquote><p>Pour rappel, par d√©finition, un type <code>A</code> est un sous-type de lui-m√™me (c.-√†-d. <code>A &lt;: A</code>).</p><p>Pour rappel, n&rsquo;utilisez pas la classe <code>&lt;:&lt;[A,B]</code>.</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><pre><code class=language-scala>sealed trait SubTypeOf[A,B]
final case class SubTypeEvidence[A &lt;: B, B]() extends SubTypeOf[A,B]
</code></pre><p><details><summary><strong>Remarque pour les personnes √† l&rsquo;aise en <em>Scala</em></strong> <em>(cliquer pour d√©voiler)</em></summary></p><p>En production, il est pratique de d√©finir <code>SubTypeOf</code> de la mani√®re √©quivalente suivante:</p><pre><code class=language-scala>sealed trait SubTypeOf[A,B]
object SubTypeOf {
  final case class Evidence[A &lt;: B, B]() extends SubTypeOf[A,B]

  implicit def evidence[A &lt;: B, B]: SubTypeOf[A,B] = Evidence[A,B]()

  def apply[A,B](implicit ev: SubTypeOf[A,B]): ev.type = ev
}
</code></pre><p></details></p><p></details></p></li></ul><h3 id=cas-d-utilisation-√©viter-les-messages-d-erreur-de-scalac-√†-propos-des-bornes-non-respect√©es>Cas d&rsquo;Utilisation: √âviter les messages d&rsquo;erreur de <em>scalac</em> √† propos des bornes non respect√©es</h3><p>Dans cet exemple, nous voulons mod√©liser le r√©gime alimentaire de certains animaux.
Commen√ßons par d√©finir le type <code>Food</code> (c.-√†-d. nourriture) et quelques-uns de ces sous-types:</p><pre><code class=language-scala>trait Food
class Vegetable extends Food
class Fruit extends Food
</code></pre><p>et maintenant la classe repr√©sentant les animaux mangeant de la nourriture de type <code>A</code>
(c.-√†-d. <code>Vegetable</code>, <code>Fruit</code>, etc):</p><pre><code class=language-scala>class AnimalEating[A &lt;: Food]

val elephant : AnimalEating[Vegetable] =
  new AnimalEating[Vegetable]
</code></pre><p>D√©finissons une fonction comme il en existe tant en <em>Programmation Fonctionnelle</em>
et passons lui <code>elephant</code> comme argument:</p><pre><code class=language-scala>def dummy[F[_],A](fa: F[A]): String = &quot;Ok!&quot;
</code></pre><pre><code class=language-scala>scala&gt; dummy[List, Int](List(1,2,3))
res0: String = Ok!

scala&gt; dummy[Option, Boolean](Some(true))
res1: String = Ok!

scala&gt; dummy[AnimalEating, Vegetable](elephant)
            ^
       error: kinds of the type arguments (AnimalEating,Vegetable)
       do not conform to the expected kinds of the type parameters (type F,type A).

       AnimalEating's type parameters do not match type F's expected parameters:
       type A's bounds &lt;: Food are stricter than
       type _'s declared bounds &gt;: Nothing &lt;: Any
</code></pre><ul><li><p><strong>Question 1:</strong> Pourquoi <em>scalac</em> se plaint il?</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><p>La fonction <code>dummy</code> requiert que son argument <code>F</code>, qui est un constructeur
de type comme le sont <code>List</code>, <code>Option</code>, <code>Future</code>, etc, accepte n&rsquo;importe quel type
en argument afin qu&rsquo;il soit toujours possible d&rsquo;√©crire <code>F[A]</code> pour n&rsquo;importe quel type <code>A</code>.
Hors <code>AnimalEating</code> impose que son argument soit un sous-type de <code>Food</code>.
Donc <code>AnimalEating</code> ne peut √™tre utilis√© comme argument <code>F</code> de <code>dummy</code>.</p><p></details></p></li></ul><p>Le probl√®me est que, en d√©finissant <code>class AnimalEating[A &lt;: Food]</code>,
nous avons impos√© √† <code>A</code> d&rsquo;√™tre un sous-type de <code>Food</code>. Donc <em>Scala</em>, tout comme <em>Java</em>,
nous interdit de donner √† <code>AnimalEating</code>, en tant qu&rsquo;argument <code>A</code>, autre chose
qu&rsquo;un sous-type de <code>Food</code> (en incluant <code>Food</code> lui-m√™me):</p><pre><code class=language-scala>scala&gt; type T1 = AnimalEating[Int]
                 ^
       error: type arguments [Int] do not conform
       to class AnimalEating's type parameter bounds [A &lt;: Food]

scala&gt; type T2 = AnimalEating[Food]
defined type alias T2
</code></pre><p>Nous sommes face √† un dilemme: afin d&rsquo;utiliser la fonction <code>dummy</code>, que nous tenons
beaucoup √† utiliser parce c&rsquo;est une fonction tr√®s utile, il nous faut supprimer la
contrainte <code>A &lt;: Food</code> de la d√©finition <code>class AnimalEating[A &lt;: Food]</code>.
Mais nous tenons √©galement au fait que les animaux ne mangent que de la nourriture (<code>Food</code>)
et pas des entiers, ni des bool√©ens et encore moins des cha√Ænes de caract√®res!</p><ul><li><p><strong>Question 2:</strong> Comment pouvez vous adapter la d√©finition de <code>AnimalEating</code> telle que:</p><ul><li><p>Il soit possible d&rsquo;appeler <code>dummy</code> avec comme argument <code>elephant</code>! Nous voulons:</p><pre><code class=language-scala>scala&gt; dummy[AnimalEating, Vegetable](elephant)
res0: String = Ok!
</code></pre></li><li><p><em>Si</em> <code>A</code> <strong>n&rsquo;est pas un sous-type</strong> de <code>Food</code> (<code>Food</code> lui-m√™me inclus),
<em>alors</em> il doit √™tre <strong>impossible</strong> de cr√©er une instance de <code>AnimalEating[A]</code>.</p></li><li><p>La classe <code>AnimalEating</code> <strong>doit</strong> rester une classe ouverte
(c.-√†-d. non <code>sealed</code> ou <code>final</code>)! Il doit toujours √™tre possible pour n&rsquo;importe qui,
n&rsquo;importe quand, de cr√©er librement des sous-classes de <code>AnimalEating</code>.
Bien √©videmment, ces sous-classes doivent respecter les deux contraintes
ci-dessus.</p></li></ul><p><details><summary><em>Astuce (cliquer pour d√©voiler)</em></summary></p><p>En <em>Scala</em>, <code>Nothing</code> est un type ne contenant aucune valeur.
Pouvez vous cr√©er une valeur de type <code>(Nothing, Int)</code>? Pourquoi?</p><p></details></p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><p>Si, afin de cr√©er une instance de <code>AnimalEating[A]</code>, nous for√ßons <strong>chaque</strong>
m√©thode cr√©ant des valeurs √† prendre un param√®tre suppl√©mentaire de type <code>SubTypeOf[A, Food]</code>,
alors il sera uniquement possible de cr√©er une instance de <code>AnimalEating[A]</code>
quand <code>A</code> sera un sous-type de <code>Food</code>:</p><pre><code class=language-scala>class AnimalEating[A](ev : SubTypeOf[A, Food])

val elephant : AnimalEating[Vegetable] =
  new AnimalEating[Vegetable](SubTypeEvidence[Vegetable, Food])
</code></pre><p>Pour cr√©er une valeur de type <code>AnimalEating[A]</code>, nous avons besoin d&rsquo;appeler
le constructeur d&rsquo;<code>AnimalEating</code>. Pour appeler ce constructeur,
il nous faut fournir <code>ev : SubTypeOf[A, Food]</code>.</p><p>Il nous est d√©sormais possible d&rsquo;appeler la fonction <code>dummy</code> sur <code>elephant</code>:</p><pre><code class=language-scala>scala&gt; dummy[AnimalEating, Vegetable](elephant)
res0: String = Ok!
</code></pre><p>En pratique, en utilisant des implicites, le compilateur peut
fournir de lui-m√™me le param√®tre <code>ev : SubTypeOf[A, Food]</code>.</p><p>Notez qu&rsquo;il est d√©sormais possible d&rsquo;√©crire le type <code>AnimalEating[Int]</code>
mais vous ne pourrez jamais cr√©er une valeur de ce type.</p><p></details></p></li></ul><h3 id=cas-d-utilisation-fournir-les-bonnes-donn√©es-au-bon-diagramme>Cas d&rsquo;Utilisation: Fournir les bonnes donn√©es au bon diagramme</h3><p>Ce cas d&rsquo;utilisation traite des m√©thodes pour garantir, √† la compilation,
que seulement les valeurs du bon type peuvent √™tre donn√©es √† une fonction donn√©e.
L&rsquo;exemple choisi est celui de la conception d&rsquo;une biblioth√®que de graphiques.
Afin de simplifier l&rsquo;exemple, nous consid√®rerons que notre biblioth√®que n&rsquo;impl√©mente
que deux types de graphique:
des <a href="https://www.google.com/search?q=pie+chart&amp;tbm=isch">camemberts (c.-√†-d. pie charts)</a>
et des <a href="https://www.google.com/search?q=xy+charts&amp;tbm=isch">graphiques dit XY (c.-√†-d. XY charts)</a>.
Cela s&rsquo;√©crit en <em>Scala</em> via l&rsquo;√©num√©ration:</p><pre><code class=language-scala>sealed trait ChartType
case object PieChart extends ChartType
case object XYChart extends ChartType
</code></pre><p>Bien √©videmment les camemberts (<em>Pie</em>) et graphiques <em>XY</em> s&rsquo;appuient sur des jeux de donn√©es de
nature diff√©rente. Encore une fois, pour simplifier, nous consid√®rerons que les deux types
de donn√©es sont <code>PieData</code> pour les camemberts et <code>XYData</code> pour les graphiques <em>XY</em>:</p><pre><code class=language-scala>class PieData
class XYData
</code></pre><p>Un camembert (<code>PieChart</code>) n&rsquo;affiche <strong>que</strong> des donn√©es <code>PieData</code>,
alors qu&rsquo;un graphique <em>XY</em> (<code>XYChart</code>) n&rsquo;affiche <strong>que</strong> des donn√©es <code>XYData</code>.
Voici, grandement simplifi√©e, la fonction d&rsquo;affichage <code>draw</code>:</p><pre><code class=language-scala>def draw[A](chartType: ChartType)(data: A): Unit =
  chartType match {
    case PieChart =&gt;
      val pieData = data.asInstanceOf[PieData]
      // Faire des trucs pour tracer les donn√©es pieData
      ()
    case XYChart =&gt;
      val xyData = data.asInstanceOf[XYData]
      // Faire des trucs pour tracer les donn√©es xyData
      ()
  }
</code></pre><p>Cette fonction repose sur l&rsquo;hypoth√®se que l&rsquo;utilisateur¬∑rice n&rsquo;appellera la
fonction <code>draw</code> que sur le bon type de donn√©es.
Quand <code>chartType</code> vaut <code>PieChart</code>, la fonction pr√©suppose, via
<code>data.asInstanceOf[PieData]</code> que <code>data</code> est en fait du type <code>PieData</code>.
Et quand <code>chartType</code> vaut <code>XYChart</code>, elle pr√©suppose que <code>data</code> est en fait
de type <code>XYData</code>.</p><p>Le probl√®me est que ces suppositions reposent sur l&rsquo;id√©e que les utilisateurs¬∑rices et/ou
d√©veloppeurs¬∑euses s&rsquo;assureront toujours que ces hypoth√®ses soient bien respect√©es.
Mais <strong>rien</strong> n&rsquo;emp√™che quelqu&rsquo;un¬∑e d&rsquo;appeler <code>draw</code> sur un camembert (<code>PieChart</code>)
avec des donn√©es de type <code>XYData</code> (ou le contraire),
faisant planter le syst√®me mis√©rablement en production!</p><pre><code class=language-scala>scala&gt; draw(PieChart)(new XYData)
java.lang.ClassCastException: XYData cannot be cast to PieData
  at .draw(&lt;pastie&gt;:11)
  ... 28 elided
</code></pre><p>En tant que d√©veloppeurs¬∑euses, nous savons que les erreurs, √ßa arrive!
Nous voulons un moyen d&rsquo;emp√™cher ces bogues ennuyeux de survenir en production!
Nous voulons imposer, √† la compilation, que seulement deux scenarii soit possibles:</p><ul><li>Quand <code>draw</code> est appel√©e avec <code>chartType == PieChart</code>:
l&rsquo;argument <code>data</code> doit √™tre de type <code>PieData</code></li><li>Quand <code>draw</code> est appel√©e avec <code>chartType == XYChart</code>:
l&rsquo;argument <code>data</code> doit √™tre de type <code>XYData</code>.</li></ul><p>Pour rappel, ces deux contraintes doivent √™tre v√©rifi√©es √† la compilation!</p><ul><li><p><strong>Question 1:</strong> Adaptez les d√©finitions de <code>ChartType</code>, <code>PieChart</code>, <code>XYChart</code> et <code>draw</code> telles que:</p><ul><li><p>Tout scenario diff√©rent des deux ci-dessus fera √©chouer la compilation sur une erreur de type.</p></li><li><p><code>ChartType</code> doit toujours √™tre un <code>sealed trait</code>. Mais il est autoris√© √† prendre des <em>param√®tres de type</em> (c.-√†-d. <em>generics</em>).</p></li><li><p><code>PieChart</code> et <code>XYChar</code> doivent toujours √™tre des <code>case object</code>
et ils doivent toujours √©tendre <code>ChartType</code>.</p></li><li><p>Les d√©clarations de <code>ChartType</code>, <code>PieChart</code> et <code>XYChar</code>
ne doivent <strong>pas</strong> avoir <strong>de corps</strong> du tout
(c.-√†-d. il ne doit pas y avoir d&rsquo;accolades <code>{ ... }</code> dans leurs d√©clarations);</p></li></ul><p><details><summary><em>Astuce (cliquer pour d√©voiler)</em></summary></p><p>Le code ressemble √† ceci:</p><pre><code class=language-scala>sealed trait ChartType[/*METTRE LES GENERICS ICI*/]
case object PieChart extends ChartType[/*Il y a quelque chose √† √©crire ici*/]
case object XYChart extends ChartType[/*Il y a quelque chose √† √©crire ici aussi*/]

def draw[A](chartType: ChartType[/*Ecrire quelque chose ici*/])(data: A): Unit =
 chartType match {
    case PieChart =&gt;
      val pieData : PieData = data
      ()
    case XYChart =&gt;
      val xyData: XYData = data
      ()
    }
</code></pre><p></details></p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><pre><code class=language-scala>sealed trait ChartType[A]
case object PieChart extends ChartType[PieData]
case object XYChart extends ChartType[XYData]

def draw[A](chartType: ChartType[A])(data: A): Unit =
 chartType match {
    case PieChart =&gt;
      val pieData : PieData = data
      ()
    case XYChart =&gt;
      val xyData: XYData = data
      ()
    }
</code></pre><p></details></p></li></ul><p>Vous pouvez maintenant dormir sur vos deux oreilles avec l&rsquo;assurance que
votre code en production ne plantera pas √† cause d&rsquo;une entr√©e non conforme
√† cet endroit üòâ</p><h2 id=cas-d-utilisation-plus-avanc√©s>Cas d&rsquo;Utilisation Plus Avanc√©s</h2><p>Maintenant que vous avez vu ce que sont les <em>GADTs</em> et comment les utiliser dans
la vie de tous les jours, vous √™tes pr√™t¬∑e pour les cas d&rsquo;utilisations plus cons√©quents
ci-dessous.
Il y en a trois. Chacun illustre une mani√®re diff√©rente d&rsquo;utiliser la puissance des <em>GADTs</em>.
Le <a href=#cas-d-utilisation-les-effets>premier</a> traite de l&rsquo;expression d&rsquo;effets,
ce qui est tr√®s largement utilis√© dans chaque monade <em>IO</em> populaire ou effets alg√©briques.
Ne vous inqui√©tez pas de ne pas savoir ce que sont ces derniers, cette section l&rsquo;expliquera.
Le <a href=#cas-d-utilisation-s-assurer-que-les-types-sont-pris-en-charge-par-la-base-de-donn%C3%A9es>second</a>
s&rsquo;attache √† montrer comment garantir des propri√©t√©s dans le syst√®me de types.
Ce point est illustr√© √† travers l&rsquo;exemple de l‚Äôaccommodation des techniques issues
de la programmation fonctionnelle aux contraintes issues des bases de donn√©es.
Le <a href=#cas-d-utilisation-simplifier-les-implicites>troisi√®me</a> offre une mani√®re plus simple
de travailler avec des implicites.</p><h3 id=cas-d-utilisation-les-effets>Cas d&rsquo;Utilisation: Les Effets!</h3><p>Ce qui est appel√© un effet est parfois juste une interface d√©clarant quelques
fonctions d√©pourvues d&rsquo;impl√©mentation. Par exemple nous pouvons d√©finir le
<code>trait</code> ci-dessous. Notez qu&rsquo;<em>aucune</em> de ces fonctions n&rsquo;a d&rsquo;impl√©mentation.</p><pre><code class=language-scala>trait ExampleEffectSig {
  def echo[A](value: A): A
  def randomInt : Int
  def ignore[A](value: A): Unit
}
</code></pre><p>Les impl√©mentations de ces interfaces (traits) sont donn√©es ailleurs, et il peut en avoir beaucoup!
Cela est utile quand il est d√©sirable de changer facilement d&rsquo;impl√©mentation:</p><pre><code class=language-scala>object ExampleEffectImpl extends ExampleEffectSig {
  def echo[A](value: A): A = value
  def randomInt : Int = scala.util.Random.nextInt()
  def ignore[A](value: A): Unit = ()
}
</code></pre><p>Une mani√®re √©quivalente de d√©finir <code>ExampleEffectSig</code> est via un <code>sealed trait</code>
muni de quelques <code>final case class</code> (peut-√™tre aucune!) et/ou quelques <code>case object</code> (peut-√™tre aucun!):</p><pre><code class=language-scala>sealed trait ExampleEffect[A]
final case class  Echo[A](value: A) extends ExampleEffect[A]
final case object RandomInt extends ExampleEffect[Int]
final case class  Ignore[A](value: A) extends ExampleEffect[Unit]
</code></pre><p>De nouveau, nous avons des d√©clarations ne fournissant aucune impl√©mentation!
De nouveau, leurs impl√©mentations peuvent √™tre fournies ailleurs et il peut en avoir beaucoup:</p><pre><code class=language-scala>def runExampleEffect[A](effect: ExampleEffect[A]): A =
  effect match {
    case Echo(value) =&gt; value
    case RandomInt   =&gt; scala.util.Random.nextInt()
    case Ignore(_)   =&gt; ()
  }
</code></pre><p>Prenons un effet plus r√©aliste ainsi qu&rsquo;une de ses impl√©mentations possibles:</p><pre><code class=language-scala>trait EffectSig {
  def currentTimeMillis: Long
  def printLn(msg: String): Unit
  def mesure[X,A](fun: X =&gt; A, arg: X): A
}

object EffectImpl extends EffectSig {
  def currentTimeMillis: Long =
    System.currentTimeMillis()

  def printLn(msg: String): Unit =
    println(msg)

  def mesure[X,A](fun: X =&gt; A, arg: X): A = {
    val t0 = System.currentTimeMillis()
    val r  = fun(arg)
    val t1 = System.currentTimeMillis()
    println(s&quot;Took ${t1 - t0} milli-seconds&quot;)
    r
  }
}
</code></pre><ul><li><p><strong>Question 1:</strong> Tout comme <code>ExampleEffect</code> est l&rsquo;√©quivalent de <code>ExampleEffectSig</code>
via la d√©finition d&rsquo;un <code>sealed trait</code> muni de quelques <code>final case class</code> et
<code>case object</code>, √©crivez l&rsquo;√©quivalent de <code>EffectSig</code> de la m√™me mani√®re.
Appelez ce trait <code>Effect</code>.</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><pre><code class=language-scala>sealed trait Effect[A]
final case object CurrentTimeMillis extends Effect[Long]
final case class  PrintLn(msg: String) extends Effect[Unit]
final case class  Mesure[X,A](fun: X =&gt; A, arg: X) extends Effect[A]
</code></pre><p></details></p></li><li><p><strong>Question 2:</strong> √âcrivez la fonction <code>def run[A](effect: Effect[A]): A</code> qui reproduit l&rsquo;impl√©mentation de
<code>EffectImpl</code> tout comme <code>runExampleEffect</code> reproduit celle de <code>ExampleEffectImpl</code>.</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><pre><code class=language-scala>def run[A](effect: Effect[A]): A =
  effect match {
    case CurrentTimeMillis =&gt;
      System.currentTimeMillis()

    case PrintLn(msg) =&gt;
      println(msg)

    case Mesure(fun, arg) =&gt;
      val t0 = System.currentTimeMillis()
      val r  = fun(arg)
      val t1 = System.currentTimeMillis()
      println(s&quot;Took ${t1 - t0} milli-seconds&quot;)
      r
  }
</code></pre><p></details></p></li></ul><p>Le type <code>Effect[A]</code> d√©clare des effets int√©ressants (<code>CurrentTimeMillis</code>,
<code>PrintLn</code> et <code>Mesure</code>) mais pour √™tre r√©ellement utile, il doit √™tre possible
de cha√Æner ces effets! Pour ce faire, nous voulons pouvoir disposer des deux fonctions suivantes:</p><ul><li><code>def pure[A](value: A): Effect[A]</code></li><li><code>def flatMap[X,A](fx: Effect[X], f: X =&gt; Effect[A]): Effect[A]</code></li></ul><p>De nouveau, nous ne nous int√©ressons pas √† leurs impl√©mentations. Tout ce que nous
voulons, pour le moment, est d√©clarer ces deux op√©rations de la m√™me mani√®re que
nous avons d√©clar√© <code>CurrentTimeMillis</code>, <code>PrintLn</code> et <code>Mesure</code>.</p><ul><li><p><strong>Question 3:</strong> Ajoutez deux <em>final case classes</em>, <code>Pure</code> et <code>FlatMap</code>,
√† <code>Effect[A]</code> d√©clarant ces deux op√©rations.</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><pre><code class=language-scala>sealed trait Effect[A]
final case object CurrentTimeMillis extends Effect[Long]
final case class  PrintLn(msg: String) extends Effect[Unit]
final case class  Mesure[X,A](fun: X =&gt; A, arg: X) extends Effect[A]
final case class  Pure[A](value: A) extends Effect[A]
final case class  FlatMap[X,A](fx: Effect[X], f: X =&gt; Effect[A]) extends Effect[A]
</code></pre><p></details></p></li><li><p><strong>Question 4:</strong> Adaptez la fonction <code>run</code> pour g√©rer ces deux nouveaux cas.</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><pre><code class=language-scala>def run[A](effect: Effect[A]): A =
  effect match {
    case CurrentTimeMillis =&gt;
      System.currentTimeMillis()

    case PrintLn(msg) =&gt;
      println(msg)

    case Mesure(fun, arg) =&gt;
      val t0 = System.currentTimeMillis()
      val r  = fun(arg)
      val t1 = System.currentTimeMillis()
      println(s&quot;Took ${t1 - t0} milli-seconds&quot;)
      r

    case Pure(a) =&gt;
      a

    case FlatMap(fx, f) =&gt;
      val x  = run(fx)
      val fa : Effect[A] = f(x)
      run(fa)
  }
</code></pre><p></details></p></li><li><p><strong>Question 5:</strong> Ajoutez les deux m√©thodes suivantes au trait <code>Effect[A]</code> pour obtenir:</p><pre><code class=language-scala>sealed trait Effect[A] {
  final def flatMap[B](f: A =&gt; Effect[B]): Effect[B] = FlatMap(this, f)
  final def map[B](f: A =&gt; B): Effect[B] = flatMap[B]((a:A) =&gt; Pure(f(a)))
}
</code></pre><p>Et ex√©cutez le code suivant pour voir s&rsquo;il fonctionne:</p><pre><code class=language-scala>val effect1: Effect[Unit] =
  for {
    t0 &lt;- CurrentTimeMillis
    _  &lt;- PrintLn(s&quot;The current time is $t0&quot;)
  } yield ()

run(effect1)
</code></pre><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><pre><code class=language-scala>sealed trait Effect[A] {
  final def flatMap[B](f: A =&gt; Effect[B]): Effect[B] = FlatMap(this, f)
  final def map[B](f: A =&gt; B): Effect[B] = flatMap[B]((a:A) =&gt; Pure(f(a)))
}
final case object CurrentTimeMillis extends Effect[Long]
final case class  PrintLn(msg: String) extends Effect[Unit]
final case class  Mesure[X,A](fun: X =&gt; A, arg: X) extends Effect[A]
final case class  Pure[A](value: A) extends Effect[A]
final case class  FlatMap[X,A](fx: Effect[X], f: X =&gt; Effect[A]) extends Effect[A]

def run[A](effect: Effect[A]): A =
  effect match {
    case CurrentTimeMillis =&gt;
      System.currentTimeMillis()

    case PrintLn(msg) =&gt;
      println(msg)

    case Mesure(fun, arg) =&gt;
      val t0 = System.currentTimeMillis()
      val r  = fun(arg)
      val t1 = System.currentTimeMillis()
      println(s&quot;Took ${t1 - t0} milli-seconds&quot;)
      r

    case Pure(a) =&gt;
      a

    case FlatMap(fx, f) =&gt;
      val x  = run(fx)
      val fa : Effect[A] = f(x)
      run(fa)
  }

val effect1: Effect[Unit] =
  for {
    t0 &lt;- CurrentTimeMillis
    _  &lt;- PrintLn(s&quot;The current time is $t0&quot;)
  } yield ()
</code></pre><p>En ex√©cutant <code>run(effect1)</code> on obtient:</p><pre><code class=language-scala>scala&gt; run(effect1)
The current time is 1569773175010
</code></pre><p></details></p></li></ul><p>F√©licitations! Vous venez d&rsquo;√©crire votre premi√®re monade <em>IO</em>! Il y
a de nombreux noms scientifiques au <code>sealed trait Effect[A]</code>:
vous pouvez l&rsquo;appeler un <em>effet alg√©brique</em>, une <em>monade libre</em>, une <em>IO</em>, etc.
Mais au bout du compte, ce n&rsquo;est qu&rsquo;un simple et banal <code>sealed trait</code> pour lequel
nous avons d√©fini quelques <code>final case class</code> et <code>case object</code> afin de
repr√©senter les fonctions dont nous voulions disposer sans fournir
leurs impl√©mentations (<code>CurrentTimeMillis</code>, <code>PrintLn</code>, <code>Mesure</code>,
<code>Pure</code> et <code>FlatMap</code>). Vous pouvez les appeler des <em>m√©thodes virtuelles</em> si vous voulez.
<strong>Ce qui importe r√©ellement est d&rsquo;avoir isol√© la d√©finition de ces fonctions de leurs impl√©mentations.</strong>
Rappelez vous qu&rsquo;un <code>trait</code> est juste une interface apr√®s tout.</p><h3 id=cas-d-utilisation-s-assurer-que-les-types-sont-pris-en-charge-par-la-base-de-donn√©es>Cas d&rsquo;Utilisation: S&rsquo;assurer que les types sont pris en charge par la Base De Donn√©es.</h3><p>Les bases de donn√©es sont formidables. Nous pouvons y stocker des tables, des documents,
des paires clef/valeur, des graphes, etc.
Mais, pour n&rsquo;importe quelle base de donn√©es, il y a malheureusement seulement un nombre limit√©
de types pris en charge.
Prenez la base de donn√©es que vous voulez, je suis s√ªr de pouvoir trouver des types qu&rsquo;elle
ne prend pas en charge.</p><p>Dans cette section, nous allons nous int√©resser au cas des structures des donn√©es
et du code qui ne marche pas pour tout les types, mais seulement certains! Ce cas d&rsquo;usage
ne se limite pas aux bases de donn√©es mais concerne chaque <em>interface de programmation</em> qui ne
supporte qu&rsquo;un nombre limit√© de types (la vaste majorit√© des <em>interfaces de programmation</em>).
Comment s&rsquo;assurer du respect de ces contraintes? Comment adapter les techniques que nous aimons
afin qu&rsquo;elles travaillent sous ces contraintes? Voil√† ce dont il s&rsquo;agit dans cette section.</p><p>Nous consid√©rerons une base de donn√©es fictive qui ne prend en charge <strong>que</strong> les types suivants:</p><ol><li><code>String</code></li><li><code>Double</code></li><li><code>(A,B)</code> o√π <code>A</code> et <code>B</code> sont √©galement des types pris en charge par la base de donn√©es.</li></ol><p>Cela signifie que les valeurs stock√©es dans la base de donn√©es (dans des tables, des paires clef/valeur,
etc) <strong>doivent</strong> respecter les r√®gles ci-dessus. Elle peut stocker <code>&quot;Hello World&quot;</code> parce que c&rsquo;est une
<code>String</code>, qui est est un type pris en charge par la base de donn√©es en vertu de la r√®gle <em>1</em>.
Pour les m√™mes raisons, elle peut stocker <code>5.2</code> parce que c&rsquo;est un <code>Double</code>,
mais elle ne peut <strong>pas</strong> stocker l&rsquo;entier <code>5</code> parce que c&rsquo;est un<code>Int</code>.
Elle peut stocker <code>(&quot;Hello World&quot;, 5.2)</code> gr√¢ce √† la r√®gle <em>3</em> ainsi que
<code>((&quot;Hello World&quot;, 5.2) , 8.9)</code>, de nouveau gr√¢ce √† la r√®gle <em>3</em>.</p><ul><li><p><strong>Question 1:</strong> D√©finissez le type <code>DBType[A]</code> tel que:</p><blockquote><p>Il existe une valeur de type <code>DBType[A]</code> <strong>si et seulement si</strong> <code>A</code>
est un type pris en charge par la base de donn√©es.</p></blockquote><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><p>La version simple est:</p><pre><code class=language-scala>sealed trait DBType[A]
final case object DBString extends DBType[String]
final case object DBDouble extends DBType[Double]
final case class  DBPair[A,B](first: DBType[A], second: DBType[B]) extends DBType[(A,B)]
</code></pre><p><details><summary><strong>Remarque pour les personnes √† l&rsquo;aise en <em>Scala</em></strong> <em>(cliquer pour d√©voiler)</em></summary></p><p>En utilisant toutes les chouettes fonctionnalit√©s syntaxiques de <em>Scala</em>,
la version satisfaisante en production du code ci-dessus est:</p><pre><code class=language-scala>sealed trait DBType[A]
object DBType {
  final case object DBString extends DBType[String]
  final case object DBDouble extends DBType[Double]
  final case class DBPair[A,B](first: DBType[A], second: DBType[B]) extends DBType[(A,B)]

  implicit val dbString : DBType[String] =
    DBString

  implicit val dbDouble : DBType[Double] =
    DBDouble

  implicit def dbPair[A,B](implicit first: DBType[A], second: DBType[B]): DBType[(A,B)] =
    DBPair(first, second)

  def apply[A](implicit ev: DBType[A]): ev.type = ev
}
</code></pre><p></details></p><p></details></p></li></ul><p>En utilisant <code>DBType</code>, nous pouvons coupler une valeur de type <code>A</code>
avec une valeur de type <code>DBType[A]</code>, fournissant ainsi la preuve que
le type <code>A</code> est pris en charge par la base de donn√©es:</p><pre><code class=language-scala>final case class DBValue[A](value: A)(implicit val dbType: DBType[A])
</code></pre><p>Notez que le param√®tre <code>dbType</code> n&rsquo;a nullement besoin d&rsquo;√™tre implicite!
Ce qui compte est que pour cr√©er une valeur de type <code>DBValue[A]</code>,
nous devons fournir une valeur de type <code>DBType[A]</code>
ce qui force <code>A</code> √† √™tre un type pris en charge par la base de donn√©es.</p><p>Un <em>foncteur</em> est, de mani√®re informelle et approximative, un constructeur de type<code>F</code>,
comme <code>List</code>, <code>Option</code>, <code>DBValue</code>, etc,
pour lequel il est possible de fournir une instance du trait:</p><pre><code class=language-scala>trait Functor[F[_]] {
  def map[A,B](fa: F[A])(f: A =&gt; B): F[B]
}
</code></pre><p>o√π <code>map(fa)(f)</code> applique la fonction <code>f</code> √† chaque valeur de type <code>A</code> contenue dans <code>fa</code>. Par exemple:</p><pre><code class=language-scala>implicit object OptionFunctor extends Functor[Option] {
  def map[A,B](fa: Option[A])(f: A =&gt; B): Option[B] =
    fa match {
      case Some(a) =&gt; Some(f(a))
      case None =&gt; None
    }
}
</code></pre><ul><li><p><strong>Question 2:</strong> √âcrivez une instance de <code>Functor[DBValue]</code>.</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><p>C&rsquo;est en fait impossible! Si nous tentions de compiler le code suivant:</p><pre><code class=language-scala>object DBValueFunctor extends Functor[DBValue] {
  def map[A,B](fa: DBValue[A])(f: A =&gt; B): DBValue[B] =
    DBValue[B](f(fa.value))
}
</code></pre><p><em>Scala</em> r√¢lerait: <code>could not find implicit value for parameter dbType: DBType[B]</code>. En effet, les bool√©ens
ne sont pas un type pris en charge par la base de donn√©es:
ils ne sont ni des cha√Ænes de caract√®res, ni des nombres flottants, ni des paires de types pris en charge.</p><p>Supposons que nous puissions d√©finir une instance de <code>Funcor</code> pour <code>DBValue</code>
(c.-√†-d. que nous puissions d√©finir une fonction <code>map</code> pour <code>DBValue</code>), alors nous pourrions √©crire:</p><pre><code class=language-scala>val dbValueString  : DBValue[String]  = DBValue(&quot;A&quot;)(DBString)
val dbValueBoolean : DBValue[Boolean] = dbValueString.map(_ =&gt; true)
val dbTypeBoooean  : DBType[Boolean]  = dbValueBoolean.dbType
</code></pre><p>Nous obtiendrions une valeur (<code>dbTypeBoooean</code>) de type <code>DBType[Boolean]</code>
ce qui signifirait que le type <code>Boolean</code> est pris en charge par la base de donn√©es.
Mais il ne l&rsquo;est pas! Hors par d√©finition:</p><blockquote><p>Il existe une valeur de type <code>DBType[A]</code> <strong>si et seulement si</strong> <code>A</code>
est un type pris en charge par la base de donn√©e.</p></blockquote><p>Donc il est impossible d&rsquo;obtenir une valeur de type <code>DBType[Boolean]</code>
et donc il est impossible d&rsquo;√©crire une fonction <code>map</code> pout <code>DBValue</code>.
Ainsi il n&rsquo;y a aucun moyen de d√©finir une instance de <code>Functor</code> pour <code>DBValue</code>. CQDF.</p><p></details></p></li></ul><p>Un <em>Foncteur G√©n√©ralis√©</em> est tr√®s similaire √† un <code>Functor</code> classique, √† la diff√©rence pr√®s
que la fonction <code>map</code> ne doit pas obligatoirement √™tre applicable √† n&rsquo;importe quels
types <code>A</code> et <code>B</code> mais peut n&rsquo;√™tre applicable qu&rsquo;√† certains types <code>A</code> et <code>B</code> particuliers:</p><pre><code class=language-scala>trait GenFunctor[P[_],F[_]] {
  def map[A,B](fa: F[A])(f: A =&gt; B)(implicit evA: P[A], evB: P[B]): F[B]
}
</code></pre><p>Par exemple, <code>Set</code> (plus pr√©cis√©ment <code>TreeSet</code>) n&rsquo;est pas un foncteur!
En effet il n&rsquo;y a aucun moyen d&rsquo;√©crire une fonction <code>map</code> qui fonctionne
pour n&rsquo;importe quel type <code>B</code> (parce qu&rsquo;il est n√©cessaire d&rsquo;avoir une relation d&rsquo;ordre sur <code>B</code>).
Mais si l&rsquo;on restreint <code>map</code> aux seuls types <code>B</code> disposant d&rsquo;une relation d&rsquo;ordre, alors il devient
possible d&rsquo;√©crire:</p><pre><code class=language-scala>import scala.collection.immutable._
object TreeSetFunctor extends GenFunctor[Ordering, TreeSet] {
  def map[A,B](fa: TreeSet[A])(f: A =&gt; B)(implicit evA: Ordering[A], evB: Ordering[B]): TreeSet[B] =
    TreeSet.empty[B](evB) ++ fa.toSeq.map(f)
}
</code></pre><ul><li><p><strong>Question 3:</strong> √âcrivez une instance de <code>GenFunctor[DBType, DBValue]</code>.</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><pre><code class=language-scala>object DBValueGenFunctor extends GenFunctor[DBType, DBValue] {
  def map[A,B](fa: DBValue[A])(f: A =&gt; B)(implicit evA: DBType[A], evB: DBType[B]): DBValue[B] =
    DBValue[B](f(fa.value))(evB)
}
</code></pre><p></details></p></li></ul><p>Ce que nous avons fait ici avec <code>Functor</code> peut √™tre fait avec de nombreuses structures de donn√©es et
techniques de programmation. Il est souvent possible de restreindre la plage des types sur lesquels
la structure de donn√©e ou la classe de types (<em>type class</em>) peut op√©rer en ajoutant un param√®tre
suppl√©mentaire comme <code>ev : DBType[A]</code> aux constructeurs et m√©thodes.</p><h3 id=cas-d-utilisation-simplifier-les-implicites>Cas d&rsquo;Utilisation: Simplifier les Implicites</h3><p>Ce cas d&rsquo;utilisation est l&rsquo;un des plus int√©ressants, mais malheureusement, pas l&rsquo;un des plus simples.
Il montre comment il est possible d&rsquo;utiliser les <em>GADTs</em> pour simplifier la cr√©ation de valeurs implicites.</p><p>Des listes de valeurs dont les √©l√©ments peuvent √™tre de types diff√©rents sont appel√©es
<em>listes h√©t√©rog√®nes</em>. Elles sont g√©n√©ralement d√©finies en <em>Scala</em> presque comme
les listes classiques:</p><pre><code class=language-scala>final case class HNil() // La liste vide
final case class HCons[Head,Tail](head: Head, tail: Tail) // L'operation: `head :: tail`

val empty : HNil =
  HNil()

val oneTrueToto : HCons[Int, HCons[Boolean, HCons[String, HNil]]] =
  HCons(1, HCons(true, HCons(&quot;toto&quot;, HNil())))

val falseTrueFive: HCons[Boolean, HCons[Boolean, HCons[Int, HNil]]] =
  HCons(false, HCons(true, HCons(5, HNil())))
</code></pre><p>Comme vous pouvez le voir, il n&rsquo;y a rien de vraiment sp√©cial √† propos de ces listes.
Nous voulons d√©finir des relations d&rsquo;ordre sur les listes h√©t√©rog√®nes.
Une relation d&rsquo;ordre est une fa√ßon de comparer deux valeurs (<strong>du m√™me type!</strong>):
elles peuvent √™tres √©gales ou l&rsquo;une peut √™tre strictement plus petite que l&rsquo;autre.
Une relation d&rsquo;ordre sur le type <code>A</code> peut se d√©finir en <em>Scala</em> comme une instance
de <code>Order[A]</code> d√©fini comme suit:</p><pre><code class=language-scala>trait Order[A] {
  // vrai si et seulement si a1 &lt; a2
  def lesserThan(a1: A, a2: A): Boolean

  /* a1 et a2 sont √©gales si et seulement si
     aucune d'entre elles n'est strictement plus petite que l'autre
  */
  final def areEqual(a1: A, a2: A): Boolean = !lesserThan(a1, a2) &amp;&amp; !lesserThan(a2, a1)

  // a1 &gt; a2 si et seulement si a2 &lt; a1
  final def greaterThan(a1: A, a2: A): Boolean = lesserThan(a2, a1)

  final def lesserThanOrEqual(a1: A, a2: A): Boolean = !lesserThan(a2, a1)

  final def greaterThanOrEqual(a1: A, a2: A): Boolean = !lesserThan(a1, a2)
}

object Order {
  def apply[A](implicit ev: Order[A]): ev.type = ev

  def make[A](lg_ : (A,A) =&gt; Boolean): Order[A] =
    new Order[A] {
      def lesserThan(a1: A, a2: A): Boolean = lg_(a1,a2)
    }
}

implicit val orderInt    = Order.make[Int](_ &lt; _)
implicit val orderString = Order.make[String](_ &lt; _)
</code></pre><p>Pour rappel, nous ne comparerons que des listes de <em>m√™me type</em>:</p><ul><li>Les listes de type <code>HNil</code> seront uniquement compar√©es √† d&rsquo;autres listes de type <code>HNil</code>.</li><li>Les listes de type <code>HCons[H,T]</code> seront uniquement compar√©es √† d&rsquo;autres listes de type <code>HCons[H,T]</code>.</li></ul><p>Comparer des listes de type <code>HNil</code> est trivial parce qu&rsquo;il n&rsquo;y a qu&rsquo;une seule et unique valeur
de type <code>HNil</code> (la liste vide <code>HNil()</code>). Mais il existe de nombreuses fa√ßon de comparer des listes
de type <code>HCons[H,T]</code>.
Voici deux relations d&rsquo;ordre possibles (il en existe de nombreuses autres!):</p><ul><li><p>L&rsquo;<em>ordre lexicographique</em> (c.-√†-d. l&rsquo;ordre du dictionnaire: de la gauche vers la droite)</p><blockquote><p><code>HCons(h1,t1) &lt; HCons(h2,t2)</code> <strong>si et seulement si</strong>
<code>h1 &lt; h2</code> <em>ou</em> (<code>h1 == h2</code> <em>et</em> <code>t1 &lt; t2</code> <em>par l&rsquo;ordre lexicographique</em>).</p></blockquote><pre><code class=language-scala>sealed trait Lex[A] {
  val order : Order[A]
}

object Lex {
  def apply[A](implicit ev: Lex[A]): ev.type = ev

  implicit val lexHNil: Lex[HNil] =
    new Lex[HNil] {
      val order = Order.make[HNil]((_,_) =&gt; false)
    }

  implicit def lexHCons[Head,Tail](implicit
      orderHead: Order[Head],
      lexTail: Lex[Tail]
    ): Lex[HCons[Head, Tail]] =
    new Lex[HCons[Head, Tail]] {
      val orderTail: Order[Tail] = lexTail.order

      val order = Order.make[HCons[Head, Tail]] {
        case (HCons(h1,t1), HCons(h2,t2)) =&gt;
          orderHead.lesserThan(h1,h2) || (orderHead.areEqual(h1,h2) &amp;&amp; orderTail.lesserThan(t1,t2))
      }
    }
}
</code></pre></li><li><p>L&rsquo;<em>ordre lexicographique invers√©</em> qui est la version √† l&rsquo;envers de l&rsquo;ordre lexicographique
(c.-√†-d. de droite √† gauche)</p><blockquote><p><code>HCons(h1,t1) &lt; HCons(h2,t2)</code> <strong>si et seulement si</strong>
(<code>t1 &lt; t2</code> <em>par ordre lexicographique invers√©</em>) <em>ou</em> (<code>t1 == t2</code> <em>et</em> <code>h1 &lt; h2</code>).</p></blockquote><pre><code class=language-scala>sealed trait RevLex[A] {
  val order : Order[A]
}

object RevLex {
  def apply[A](implicit ev: RevLex[A]): ev.type = ev

  implicit val revLexHNil: RevLex[HNil] =
    new RevLex[HNil] {
      val order = Order.make[HNil]((_,_) =&gt; false)
    }

  implicit def revLexHCons[Head,Tail](implicit
      orderHead: Order[Head],
      revLexTail: RevLex[Tail]
    ): RevLex[HCons[Head, Tail]] =
    new RevLex[HCons[Head, Tail]] {
      val orderTail: Order[Tail] = revLexTail.order

      val order = Order.make[HCons[Head, Tail]] {
        case (HCons(h1,t1), HCons(h2,t2)) =&gt;
          orderTail.lesserThan(t1,t2) || (orderTail.areEqual(t1,t2) &amp;&amp; orderHead.lesserThan(h1,h2))
      }
    }
}
</code></pre></li></ul><p>Comme dit plus haut, il est possible de d√©finir davantage de relations d&rsquo;ordre:</p><ul><li><p><strong>Question 1:</strong> L&rsquo;ordre <code>Alternate</code> est d√©fini par:</p><blockquote><p><code>HCons(h1,t1) &lt; HCons(h2,t2)</code> <strong>si et seulement si</strong>
<code>h1 &lt; h2</code> <em>ou</em> (<code>h1 == h2</code> <em>et</em> <code>t1 &gt; t2</code> <em>par ordre</em> <code>Alternate</code>).</p></blockquote><p>En suivant la m√©thoe employ√©e pour <code>Lex</code> and <code>RevLex</code>,
impl√©mentez l&rsquo;ordre <code>Alternate</code>.</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><pre><code class=language-scala>sealed trait Alternate[A] {
  val order : Order[A]
}

object Alternate {
  def apply[A](implicit ev: Alternate[A]): ev.type = ev

  implicit val alternateHNil: Alternate[HNil] =
    new Alternate[HNil] {
      val order = Order.make[HNil]((_,_) =&gt; false)
    }

  implicit def alternateHCons[Head,Tail](implicit
      orderHead: Order[Head],
      alternateTail: Alternate[Tail]
    ): Alternate[HCons[Head, Tail]] =
    new Alternate[HCons[Head, Tail]] {
      val orderTail: Order[Tail] = alternateTail.order

      val order = Order.make[HCons[Head, Tail]] {
        case (HCons(h1,t1), HCons(h2,t2)) =&gt;
          orderHead.lesserThan(h1,h2) || (orderHead.areEqual(h1,h2) &amp;&amp; orderTail.greaterThan(t1,t2))
      }
    }
}
</code></pre><p></details></p></li></ul><p>Il existe de nombreuses mani√®res de d√©finir une relation d&rsquo;ordre valide sur les listes h√©t√©rog√®nes!
Cr√©er une classe de type (<em>type class</em>) comme <code>Lex</code>, <code>RevLex</code> et <code>Alternate</code> pour chaque relation
d&rsquo;ordre voulue est fatigant et propice aux erreurs. Nous pouvons faire bien mieux &hellip;
avec un <em>GADT</em> üòâ</p><pre><code class=language-scala>sealed trait HListOrder[A]
object HListOrder {
  final case object HNilOrder extends HListOrder[HNil]

  final case class HConsOrder[Head,Tail](
      orderHead: Order[Head],
      hlistOrderTail: HListOrder[Tail]
    ) extends HListOrder[HCons[Head,Tail]]

  // D√©finitions des Implicites

  implicit val hnilOrder : HListOrder[HNil] =
    HNilOrder

  implicit def hconsOrder[Head,Tail](implicit
      orderHead: Order[Head],
      hlistOrderTail: HListOrder[Tail]
    ): HListOrder[HCons[Head,Tail]] =
    HConsOrder(orderHead, hlistOrderTail)

  def apply[A](implicit ev: HListOrder[A]): ev.type = ev
}
</code></pre><p>Il est √† noter que la d√©finition de ces implicites est du pur boilerplate. Leur seule
raison d&rsquo;√™tre est de passer leurs arguments au constructeur correspondant
(c.-√†-d. <code>final case class</code> ou <code>case object</code>):
<code>hnilOrder</code> √† <code>HListOrder</code> (O arguments) et <code>hconsOrder</code> √† <code>HConsOrder</code> (2 arguments).</p><ul><li><p><strong>Question 2:</strong> √âcrivez une fonction <code>def lex[A](implicit v : HListOrder[A]): Order[A]</code>
qui retourne l&rsquo;ordre lexicographique √† partir d&rsquo;une valeur de type <code>HListOrder[A]</code>.</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><pre><code class=language-scala>def lex[A](implicit v : HListOrder[A]): Order[A] =
  v match {
    case HListOrder.HNilOrder =&gt;
      Order.make[HNil]((_,_) =&gt; false)

    case hc : HListOrder.HConsOrder[head,tail] =&gt;
      val orderHead: Order[head] = hc.orderHead
      val orderTail: Order[tail] = lex(hc.hlistOrderTail)

      Order.make[HCons[head, tail]] {
        case (HCons(h1,t1), HCons(h2,t2)) =&gt;
          orderHead.lesserThan(h1,h2) || (orderHead.areEqual(h1,h2) &amp;&amp; orderTail.lesserThan(t1,t2))
      }
  }
</code></pre><p></details></p></li><li><p><strong>Question 3:</strong> √âcrivez une fonction <code>def revLex[A](implicit v : HListOrder[A]): Order[A]</code>
qui retourne l&rsquo;ordre lexicographique invers√© √† partir d&rsquo;une valeur de type <code>HListOrder[A]</code>.</p><p><details><summary><em>Solution (cliquer pour d√©voiler)</em></summary></p><pre><code class=language-scala>def revLex[A](implicit v : HListOrder[A]): Order[A] =
  v match {
    case HListOrder.HNilOrder =&gt;
      Order.make[HNil]((_,_) =&gt; false)

    case hc : HListOrder.HConsOrder[head,tail] =&gt;
      val orderHead: Order[head] = hc.orderHead
      val orderTail: Order[tail] = revLex(hc.hlistOrderTail)

      Order.make[HCons[head, tail]] {
        case (HCons(h1,t1), HCons(h2,t2)) =&gt;
          orderTail.lesserThan(t1,t2) || (orderTail.areEqual(t1,t2) &amp;&amp; orderHead.lesserThan(h1,h2))
      }
  }
</code></pre><p></details></p></li></ul><p>Cette approche a de nombreux avantages. Alors que l&rsquo;approche initiale devait effectuer
une recherche d&rsquo;implicites pour chaque relation d&rsquo;ordre, l&rsquo;approche par <em>GADT</em> n&rsquo;a besoin
de faire cette recherche qu&rsquo;une seule fois!
Sachant que la r√©solution d&rsquo;implicites est une op√©ration gourmande, la r√©duire signifie des
temps de compilation plus courts.
Lire le code des fonctions <code>lex</code> et <code>revLex</code> est √©galement plus simple que comprendre
comment la r√©solution d&rsquo;implicites fonctionne pour les traits <code>Lex</code> et <code>RevLex</code>.
De plus, ce ne sont que des fonctions, vous pouvez y utiliser tout ce que vous pouvez
programmer afin de construire les instances de <code>Order[A]</code>.</p><h2 id=conclusion>Conclusion</h2><p>Pas si trivial, n&rsquo;est-ce pas? üòâ En fait, une grande part de la complexit√©
√† laquelle vous venez de faire face vient du triste fait que les techniques
de raisonnements sur les types et valeurs ne sont presque jamais enseign√©es dans
les cours de programmation.
Ce que vous trouvez simple maintenant (API Web, Streaming, Bases De Donn√©es, etc)
terrifierait probablement la/le jeune programmeuse¬∑eur que vous √©tiez √† votre
premier &ldquo;Hello World!&rdquo;.
Vous n&rsquo;avez probablement pas appris tout ce que vous savez en programmation en
trois heures, donc n&rsquo;attendez pas des techniques de raisonnement sur des programmes
d&rsquo;√™tres magiquement plus simples.</p><p>Cet atelier avait pour but de vous inspirer, d&rsquo;ouvrir votre esprit √† ce nouvel univers
de possibilit√©s. Si vous trouvez ces cas d&rsquo;utilisation int√©ressants, alors prenez le temps
de comprendre les techniques.</p><p>Amusez vous bien et prenez bien soin de vous ‚ù§Ô∏è</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Lire les autres posts</span><hr></div><div class=pagination__buttons><span class="button next"><a href=https://stankoua.github.io/fr/posts/fr/hello-world-post/><span class=button__text>Hello Word Post</span>
<span class=button__icon>‚Üí</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>¬© 2019 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://stankoua.github.io/assets/main.js></script><script src=https://stankoua.github.io/assets/prism.js></script></div></body></html>