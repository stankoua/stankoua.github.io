<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>Types et polymorphisme</title>
        <link rel="stylesheet" href="./css/reveal.css">
        <link rel="stylesheet" href="./css/theme/black.css" id="theme">
        <link rel="stylesheet" href="./css/highlight/zenburn.css">
        <link rel="stylesheet" href="./css/print/paper.css" type="text/css" media="print">


    </head>
    <body>

        <div class="reveal">
            <div class="slides"><section  data-markdown><script type="text/template">

<style type="text/css">
.reveal .footer {
    position: absolute;
    bottom: 0em;
    left: 1em;
    font-size: 0.5em;
  }
</style>
<script type="text/javascript">
__SCRIPT_END__

<!-- .slide: data-background="#27457b" -->

# Types et polymorphisme

#### Stéphane TANKOUA <!-- .element: style="color:pink" -->
#### (github: @stankoua / twitter: @stefshine) <!-- .element: style="color:pink" -->


<aside class="notes"><!-- Summary -->
<ul>
<li>Contexte historique</li>
<li>Présentation fonctionnelle de Scala</li>
<li>Présentation object de Scala</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Parlons de types

- Type ≈ Ensemble de valeurs

- Le système de type de Scala/TS a 2 bornes:

  - 1 borne supérieure: `Any` (`any` en TS)

  - 1 borne inférieure: `Nothing` (`never` en TS)
</script></section><section  data-markdown><script type="text/template">
# Parlons de types

- Avantages des types:

  - aide à documenter le code

  - aide à vérifier que le programme est correct

  - permet un gain de performance

  - facilite la gestion mémoire

  - besoin de moins de tests

  - facilite l'évolutivité du code (refactoring)
</script></section><section  data-markdown><script type="text/template">
# Parlons de type

Deux façons de classifier un système de type:

- **typage statique** / **typage dynamique** = Le type des expressions est-il su à la compilation ?

- **typage fort** / **typage faible** = Le bon type est-il utilisé avec la bonne opération ?

Préférences Scala: 

  - **typage statique**

  - **typage fort**
</script></section><section  data-markdown><script type="text/template">
# Parlons de type

De nombreux types de base usuels:

- booléens

- entiers (signé ou non signé): valeurs codées sur 8 bits, 16 bits, 32 bits voir 64 bits.

- caractères: parfois assimilés à des entiers codés sur 8 ou 16 bits (exemples : C et Java)

- réels: en virgule flottante.

- string

Sur la JVM (en Java/Scala), on peut définir nos propres types.
</script></section><section  data-markdown><script type="text/template">
# Parlons de type

- Cas facile à typer: opération accepte un seul type de valeur.

- Cas problèmatique (addition): 

```scala
def plus(a: Int, b: Int): Int

def plus(a: Double, b: Double): Double
```

Comment résoudre le problème ?
- code différent pour l’addition des entiers et l’addition des flottants ?

- Des opérations qui peuvent avoir plusieurs signatures ?
</script></section><section  data-markdown><script type="text/template">
# Polymorphisme

<img 
  src="resources/freezer-transformation.gif" 
  alt="logo"
  style="border: none;width: 20%;background: none;box-shadow: none;"
  />
</script></section><section  data-markdown><script type="text/template">
# Polymorphisme

> Un langage est dit être **polymorphique** si les valeurs / variables peuvent avoir plus
> d'un type. Une fonction polymorphique est une fonction dont les opérandes peuvent avoir plus
> d'un seul type. Au contraire, dans un langage **monomorphique** les valeurs / variables
> n'ont qu'un seul type.
</script></section><section  data-markdown><script type="text/template">
# Polymorphisme: génèse

- Introduit par Christopher Strachey

  - _Fundamental concepts in Programming languages_ - 1967

  - definit deux formes: **parametrique** et **ad-hoc**

- Cardelli et Wegner revoient la classification de Strachey

  - _On understanding Types, Data Abstraction and Polymorphism_ - 1985

  - référence sur le polymorphisme
</script></section><section  data-markdown><script type="text/template">
# Les types de polymorphisme

Basé sur the classification de Cardelli & Wegner

![./resources/kinds-of-polymorphism.png](data:image/png;base64,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CdgA8TNgAiZgAiZgAiZgAiZgAibQMAI2QBqG2g2ZgAmYgAmYgAmYgAmYgAnYAPEzYAImYAImYAImYAImYAIm0DACNkAahtoNmYAJmIAJmIAJmIAJmIAJ2ADxM2ACJmACJmACJmACJmACJtAwAjZAGobaDZmACZiACZiACZiACZiACdgA8TNgAiZgAiZgAiZgAiZgAibQMAI2QBqG2g2ZgAmYgAmYgAmYgAmYgAnYAPEzYAImYAImYAImYAImYAIm0DACNkAahtoNmYAJmIAJmIAJmIAJmIAJ2ADxM2ACJmACJmACJmACJmACJtAwAjZAGobaDZmACZiACZiACZiACZiACdgA8TNgAiZgAiZgAiZgAiZgAibQMAI2QBqG2g2ZgAmYgAmYgAmYgAmYgAnYAPEzYAImYAImYAImYAImYAIm0DACNkAahtoNmYAJmIAJmIAJmIAJmIAJ2ADxM2ACJmACJmACJmACJmACJtAwAjZAGobaDZmACZiACZiACZiACZiACdgA8TNgAiZgAiZgAiZgAiZgAibQMAI2QBqG2g2ZgAmYgAmYgAmYgAmYgAnYAPEzYAImYAImYAImYAImYAIm0DACNkAahtoNmYAJmIAJmIAJmIAJmIAJ2ADxM2ACJmACJmACJmACJmACJtAwAjZAGobaDZmACZiACZiACZiACZiACdgA8TNgAiZgAiZgAiZgAiZgAibQMAI2QBqG2g2ZgAmYgAmYgAmYgAmYgAnYAPEzYAImYAImYAImYAImYAIm0DACNkAahtoNmYAJmIAJmIAJmIAJmIAJ2ADxM2ACJmACJmACJmACJmACJtAwAjZAGobaDZmACZiACZiACZiACZiACdgA8TNgAiZgAiZgAiZgAiZgAibQMAI2QBqG2g2ZgAmYgAmYgAmYgAmYgAnYAPEzYAImYAImYAImYAImYAIm0DACNkAahtoNmYAJmIAJmIAJmIAJmIAJ2ADxM2ACJmACJmACJmACJmACJtAwAjZAGobaDZmACZiACZiACZiACZiACdgA8TNgAiZgAiZgAiZgAibQrQSKokh8HEygHoFx6kU6zgRMwARMwARMwARMwARGlYCMjrHGGiuK1l6Pan3O354EbIC05311r0zABEzABEzABEygSwLffvtt5OnXb8wnxWBsyPD48MMP43yyySaL+vN4SBor/+dgAhAY86fN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rLHGGvGsc47vE8HPfGDwlwmYQAsQsAHSAjfJIpqACfyPAEvs8pb3oYcfSssss0yZ8PTTT6fZZ589lizVfPky0Scm0CYEZGQw2vfzn/88esVoyDvvvBMGiJegbpMb7W6YQJsTsAHS5jfY3TOBdiLAyAbGxzPPPJMWXWTRsmusCDT33HPb+CiJ+KRdCWCAyMhYYYUVopsPPvhgevLJJ+NcIyTt2n/3ywRMoD0I2ABpj/voXphA2xPA+GBk47XXXksbbLBB2V9WvVpooYVCKevLIx8onjCyAlo+Gm1/MmDAgLTFFltEPx944IE42gek7W+7O2gCbUHABkhb3EZ3wgTam8C3Q74N4+ODDz5IO++8c3riiSeiw9ddd11aeumlS4f09qbQee94I86bcQyw6hvyzkv03RRY1fu0EhHuMYbmRBNNlFZcccUQnVHATz/91Pe/lW6kZTWBPkzABkgfvvnuugm0AgGUxX5j90tffvll7AJ9xRVDN1+76KKLYundvv7Gn/7z1pvj+++/H7dU161wfxslY8ZTsoFP7adRcnRHOzJAqGummWaKKi+++OL00UcfxXlf/00EBH+ZgAk0NYFxmlo6C2cCJtCnCYTxkZVFwoknnhgfzk8++eS00UYbcdqnRz9QNFFG33jjjfTHPx6XVwG7I6266qppt912S9/5zneCDel9PYjTF198kS677LL02WefpQknnDD4fPXVV2mKKaZIa665ZhpvvPFaBpWMjFlnnTVkZvQDI93BBEzABFqBgA2QVrhLltEE+iABKY10/cILL0x77713UDjggAPSjjvuGOdVAyUi+tiX3oQfe+yx6be//W2adNJJYyniCSaYIO233359jEbX3WXU49VXXy2fJZVgDw0MNwyQ6nOn9GY+Tj755KV47733XhqQ/UIcTMAETKDZCXgKVrPfIctnAn2UgBRBnMw32WSToLDpppum/fffP3wd+rrxoTfgn3/+eWIn+DnmmCM+gGJFpG+++SZGR5Svjz5G0W0ZahgYe+21V/rd734X8YsttlgcF1hggWDVioy4/wqtNIIjmX00ARPomwRsgPTN++5em0BTE9Byuy++9GJadtllQ1amFKE4TjLJJGnIt0OX423qTvSwcJpahSPy6quvnp577rnEjtgEFOpxxhmn5d7m9yQyeGG0EjRqwFQswtdffx3HlvoaNrOO+67A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BmnCCSf09Kuu4DndBEygaQjYAGmaW2FBTKBvEJAfCArTSiutFJ2+9dZb08cff9w3ALiXJjAGBGTAn3feeVHLAgsskFZYYYU4t+/HGIB1URMwgYYSsAHSUNxuzARMAAJ6i7vooosGkIsuuihpPxClmZQJmEBHAkO+HRIRLNxw+OGHx/mBBx6Y+vfvXy7u0LGEr0zABEygOQnYAGnO+2KpTKCtCehN7VxzzZWWXXbZ6Ou9994bR6W1NQB3zgRGkQCG+dj9xk5ffvVlOvHEE6P0aqutltZYY404t+E+ikCd3QRMoFcJ2ADpVfxu3AT6JgEZGVNNNVXacMMNA8KVV16ZPvnkk1hC1MpU33wu3OvOCWj1uNtuvS2deeaZkXHfffdNU0wxRfh+aGpW5zU4xQRMwASah4ANkOa5F5bEBPoUASlUyy23XPT7kksuSc8880yc2wDpU4+CO9sFAX4rY489dhjop556auTeZptt0oorrthFSSebgAmYQHMSsAHSnPfFUplAnyEw99xzp7XXXjv6izM6QSMkceEvEzCBIHDHHXekiy++OM532H6HNMEEE6QhQ4bEsrxGZAImYAKtRMAGSCvdLctqAm1EQEYGU0jWX3/96Nk555wTmxKSphGSNuqyu2ICo0yA0UCmV3366afptNNOi/I//vGP05JLLRnnnno1ykhdwARMoAkI2ABpgptgEUygLxLAyODtLUGO6A888EB66KGHIs7TsAKDv/o4gWJY/++///7EanGErbfeOo077rgtu+8Hv21eMDTLSwbkqfcZhr5XD+Lkfw979Ta48R4gYAOkB6C6ShMwgZEjoFGQOeecM+20005RiN2dv/nmm5jz3iwKysj1xrlMoHsJoHT2y4b6119/nS644IKofKuttkqLLbZYnOv3072t9mxt9Am5GbnR6E1W/3u20S5qR556ny6K9WiyDA5xQj7F9WjDrtwEGkRgrPxA9+4vv0EddTMmYALNSYBREBxsr7jiirTeeuuFkE899VSaZ555YoSENAcT6IsEMMBRQB999NH03e9+NxBcc801afXVV2/JfT9QN1Ck33vvvfT000+n6aabLg0cODD6hSIyVi/d5K+++qocjUUE5IT7+OOP3yv+aOKELM8//3x6880307zzzpumnHLKlrzv9MPBBGoJjFMb4WsTMAETaCQBFBLCkksumeaff/70xBNPpFtuuSUMEIyP6h/jRsrltkygtwnot3HttdeGKCuvvHJaYomhvh+t9ruQMfXcc8+llVcelF555dXo0+WXX57WXXddtH5Wn2gYcvH78ssv0wEHHJCuu+66xMaoGCMff/xxmnnmmdNvf/vbNOmkkzb83yDdd1YG3GCDDYIJBsi//vWvNNtss8XUNY0eNQyYGzKBbibgKVjdDNTVmYAJjBoB/pCiDEw77bRphx12iMKnn356OKNzQZqDCfQ1AijsKKKvv/56+uOf/hjdx/djqqla8y24lOrzzz8/jI+llloq+oSCjcJPeiN/65JnvPHGS9vkJY0xOM4666yEfCj6V1x+RUwFbfRzJwaMEsn4WHa5ZROjwpdddlmI02hWjWbg9voGARsgfeM+u5cm0NQE9Ef3e9/7Xsh5zz33pPvuuy/OpSg0dQcsnAl0MwH9Jh588MH06rDRguWXXz5akXHSzU32WHX0Rb/jzz77LNrB6Jh88snjHJ+v3ghivOCCCyZ8awhLLLFEHOeae65S5oho8Bd+PwQMo88+HcpMcQ0Wxc2ZQI8QsAHSI1hdqQmYwKgQ0HQC9gTZfffdoyhOt1988UXD34yOitzOawI9QQDFWNMP77777mhijz32SLPOOmucS5nvibZ7ok7kxWgixHSrfHzyySfThx9+GNOc8G0gjEy/YCPDIQqNxBf5ab+2LO2pLh0/+uijqPHzzz8fiZpHL4vkUJuqhWsxmGaaadIxxxyT/vvf/6aHH344sqy00kpxrOZTWY7Ef1vpazVtVM6pR59RKee8JjAqBOwDMiq0nNcETKDHCKAgjDPOOOmHP/xh+tOf/pTOPPPMtMsuu4RvSGd/cHtMGFdsAr1IgN8CBgjTcOT/wZQlLb0rg70XRRzlpmWELLPMMuFUf+edd6YBAwakQYMGRV0jUnjprwwY9V0GxYgWqajmkWJPO9q8UXHVzqj+ahr1VK+Vnzg+Q74dkh3oh/dfUbry07bqUjuSkbzVOM5/+tOfJkZnXnzxxViqnHOC8tXWSzyrpmWhIol+VuslsiqDynOUrLVskI9Q22ZE+ssExoCADZAxgOeiJmAC3UeAP4CExRZdLK2zzjrpyiuvTDhh4pzuP37dx9k1tQ4BVj/SVMT55psvBEeBbLWAzFJwkR1FWso017XpxFUD6fo3gPPaa/3bUS2D4qwyxFcVaRktiiO9Xh3EE5R/6NXw32P363ylPvVNR9XF0sMYLVUZVbPiJpxwwljxTPEcVY/i1E/Vqz5RRzWOa5VVvOrQkXSlMS2OF0KSRWWV10cTGFMCNkDGlKDLm4AJdBsB/shNOtmk4RSKAXLUUUfludlbp/nmm9dL8nYbZVfU7ASkDL/yyiulqFNNNVV53konUlzx+bj++utDqZX8KLmsMrXaaqvF6lMsMcwbeJa/pRzpE000UcI37P3334/V8R577LEwJmabbba09NJLp7nmmiuqUztccI7i/P4H76f777s/pjAx4oI/BcsZL7TQQrHiFco27alMnAz7QpHXfbjhhhui/YknnjjaloyD8ugNdfCihOMEE0xQGjrIsNxyy+VFA6aKOCnybLT6+GOPp7vuvivyL7LIIiHTW2+9lfhsvvnm6dlnn0333ntvmmKKKWIPGOpmShirBPJRX2V8IA+GKss133777endd99Nq6yyShh5MJpssslKGV599dV00003lXJR96effhrL/FL34MGDE6yeeeaZ9J3vfCexR9OKK67oJYCrD4fPu4dAfpAdTMAETKApCOQ/pCFHfvNb5D/MvOotshFSypb/4JbnPjGBdiWg30HeGyd+A1lBL95+++3ortJape+S95NPPin222+/6A+/a30mmWSSIvt6FdnYKPLUyzJe6QsvvHCRl+Uu5l9g/uHSyHPzzTcHCv5t0IeI7DtTZMU5yqywwgrFpZdeWvzkJz8p6/jFL35RZKOoxHjeeedFWl7uNo555LXIRk+k51X5ynKSi+Mbb7wRbf7lL3+pm54XEIjyZD6HqAAAQABJREFU+nfrjDPOKPP95je/Kc477+9FNhDKuDzlNPLnPVLKuGp7p5xySqTDVFyz0VJkv7ky/x/+8Idc79C+UHbVVVctHn/88SjHVzZqix/84AdlftX/u9/9rrj0kkuHiyc9GzNFXo2tbLuszCcmMAYEsKQdTMAETKApCFQViNNOO638Y5j3Dgj5UFIcTKDdCUi5lAGCAt2qBgj3Sgo454cffnj8rjEsUG6zz1eRV8YiKUJeBjfiF1hggWLqqacuMATIt/POOxfZLyyUYa6XXXbZiEc5zo7jUVb/PuQ3+JFGvjxCEko3GV5++eWIz2/640h9ClLaZYBkX5Ui++AoOQwY6kOePCpT5ClxxWuvvVam5/2Los48YlCob9l5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ERiMAD9E/MjzZu7yyy/P1G233bZMM800xsgIDEgEZHywH87ee+9d/vznPycO3/rWt8qmm26a5zw3KGztRsglBb03+cjTrA6y98bTW5+Gx0e98Iw9Vjh/NGCRPP1tU/I126MOSHU083qTtS9Z4CWP2lRXszzt8CGvtzYoC/VWlvRW2YntEKkPutZRdeGedcghh5Qf/vCHGVQ/44wzJgvlepNF5eu+hsxNkizNNM6bfeitXuWrHDy98Snfx/ZE4JM7rz3ls1RGwAgYgfJx/MCNEz8yjz/+ePnrX/+aiKywwgr5hnF4P36Gzwh0GwIyPl5++eWy/fbb13EHP/nJT8qee+5ZJplkklRS21Epk5Kr2QEMqP/973+pQOLig+wovOJTH7iWIst46rlvKp8qI8VWZeFXGufEkclNDaV6/PHHz/abPCqjdriGqBP5eBny/PPPZwA2dUhJ7+Hq/ZsZD6jZDjMmyPL222+nUj/ZZJPlilStfM1r9YtZC1ymuAY7+iFcm21QFmqmgTnYszoX8uNKpdmbHu6hvylP/XIz45q2JY/aaC0pbNi/ib7SJqtoKb3J35SR+/yNN94olKNvX/jCF8oEE0zQa7nWcWrW6fP2RMAGSHuOi6UyAkaggYBeVt7wrxsydbbZZi0EQkL+4UkY/DVAEJDxgfK72WablSuuuCJ7fuCBB5YddtghVysST7tB0nxW77///nL22Wfnfj433XRTisqiEuutt15+2GBUCi7Bz/vvv38GPmM8oPCOM/Y45b333yv33ntvOeaYY8rnP//5dA9CsWVlvAceeKCwSt6GG26YqzihOKP8nnvuueWCCy4op512Wra50UYbZXus9oTxA2EMYMgRxzHFFFNk+XfefqdMP8P05cc//nG54447yqGHHpqzsSjEv/vd78o666yTZekjpGNeDP7CsUoKNm1cfPHFGQB+9NFH12y4OLG87aqrrprKtvipT4YPAePsg0R5xWJ84xvfKF/+8pfLiiuuWJZffvmCIdPEW/U8++yz5cSTTiyXXXpZeeSRR8qrr75a/vSnP5Wll166TD311OWhhx6qZVEfMHTo45NPPplL8yI79WG07L777mnA3HbbbeXne/y8LLHkEokXy/r+97//TQOZWL1TTz21nH/++eWqq64qXC+66KJliy22KPPNN18tp2R85913ylVXXlUuu+yy5L/z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NeBHtkmf+9znygcffFAWWWSRsswyy5THHnusrLfeemXaaaYpRx19dJlhhhnqN6/Ncp1+LoWffqDMnXjiiWXxxRcvyy+//Aj3V2Pw/vvvl3/84x/lhRdeKF/84hcTd5QjjLrJJ5+8bLTRRmXCCSfMdJTKt99+O9tnzMin/Kuvvlo233zzMvXUU9eGwmfBXLJRxzHHHFO+973vlZNPPrl861vfqhWv1nujP+3prTy8OkdZ/3//7/+Vv/71r+Xmm28uSyyxRJ3XnzrHJI/6gOHx5z//udx7773lggsuyGdj1113Leuvv34Zd9xxR8qYfJp+oiTffffd5YEHHijIceSRR5ZtttlmtMvxaWQe1by6pz/48INy/333l8cffzzv7ZVXXrnstNNO/Wr+vPPOK+uuu27eq9tvv30aef0qaCYjYARGOwKeARntkLtBIzB8BKQ8ohytuOKKZdJJJy3f/e53U0lBUXnyySfyLR+GCAovR96k/uQnPyk77rhjuf3227ORx//7eLnrrrvKJZdeWh599NFM44e+G+mpp54qhx9+eFl00UXLD3/4w/L666+PlG4yBksttVR56aWXylZbbZVjsPXWW6dxsdxyy+WbWhpqjtmgQYPKe++9V7bYYouy7bbblvnmm6984QtfGCnyNCvBuDn77LMziSPGJzQiY4wLC4aVSHVwX2F8QLfddpuy2/4o4wNDkGfo3XffDazOKeecc07517/+VTbeeOPyxBNPZD/gHZ103333lQsvvDCND9rlHhvopPvt1VdeLaeffnoaEtzTzGYMj/TsXXfddcn629/+Nv8mcqF6h1eH842AERi9CPiv3ujF260ZgU+FAIrJXHPNVeaYY45y/fXX5xvBlVZaqey99z6F2Y5W2mWXXcpaa61VJphggsxabNHFymGHHVYmmmiifHNNYlPJbC3fadcoFygfGFznnntu9htDBGI24rOQlBrwmn322QPzvdOIO+WUU7JajJIvf/nLtYIjXBkzxouZpz322KNcfPHFZbXVVssykvezyEVZZKOu8ccfP+VitoeZmPHGGy/TJcunaQf/eYxV+sS9pf7POOMMqbTztp4Zg04jlNKHHnqoMG7jjjtOWXvttctpp52Ws4rTzzB9dmdE8BpRHDB2Vllllfwwhhh3n/VeHVFZ2qkcYwAeU001VfnVr36VzxCzhvpbNixZ9Vzx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)

<aside class="notes"><ul>
<li>Universal polymorphism:<ul>
<li>uniform behaviour of ops = true polymorphism</li>
</ul>
</li>
<li>Ad-hoc polymorphism:<ul>
<li>functions work a restricted number of types</li>
<li>operations behaviour depends of the type = syntactic sugar</li>
</ul>
</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Détour sur la syntaxe: Scala

```scala
val value: String = "Hello"

val tuple: (Int, String) = (1, "Hello")

def function(input: Int): String = s"Text input: $input"

sealed trait Variant

case class Record1(label: Boolean, label2: Char) extends Variant

case class Record2(label1: String, label2: Int) extends Variant
```
</script></section><section  data-markdown><script type="text/template">
# Détour sur la syntaxe: Haskell

```haskell
value :: String
value = "Hello"

tuple:: (Int, String)
tuple = (1, "Hello")

function :: Int -> String
function input = "Text input: " ++ show input

data Variant = Record1 Boolean Char | Record2 String Int
```
</script></section><section  data-markdown><script type="text/template">
# Détour sur la syntaxe: Typescript

```typescript
const value: String = "Hello"

function func(input: number): String {
  return `Text input: ${input}`
}

const func: (input: number) => string =
  (input: number) => `Text input: ${input}`

type Record1 = { label1: boolean, label2: char }

type Record2 = { label1: string, label2: number }

type Variant = Record1 | Record2
```
</script></section><section  data-markdown><script type="text/template">
# Types de Polymorphismes

<img 
  src="./resources/freezer-form-1.jpg" 
  alt="logo"
  style="border: none;width: 20%;background: none;box-shadow: none;"
  />
</script></section><section  data-markdown><script type="text/template">
# Polymorphisme paramétrique

- Un problème à résoudre:

```scala
// Scala
def length(list: List[Int]): Int = ...
def length(list: List[String]): Int = ...

length(List(1, 2, 3, 4)) // = 4
length(List("1", "2", "3", "4")) // = 4
```
</script></section><section  data-markdown><script type="text/template">
# Polymorphisme paramétrique

- aussi connu comme `generics` en `Java`:

```scala
// Scala
def length[A](list: List[A]): Int = ...

length[Int](List(1, 2, 3, 4)) // = 4
```
</script></section><section  data-markdown><script type="text/template">
# Polymorphisme paramétrique

Dans d'autres langages:

```haskell
-- Haskell
length :: [a] -> Int -- le type non connu `a` est un paramètre de type
length list = ...

length [1, 2, 3, 4] -- = 4
```

```typescript
// TS
function length<A>(list: List<A>): Int { ... }

length<number>([1, 2, 3, 4]) // = 4
```
</script></section><section  data-markdown><script type="text/template">
# Polymorphisme d'inclusion

- C'est quoi l'inclusion ?

> Un type A est **inclus dans**, ou est un **sous-type** (aussi noté `⊆`) d'un autre type B quand toutes les valeurs du
> type A sont aussi des valeurs du type B, càd exactement quand A, vu comme un ensemble de valeurs, est un sous-ensemble de B.
</script></section><section  data-markdown><script type="text/template">
# Polymorphisme d'inclusion

- Qu'est ce que cela implique ?

```typescript
// For range of integers
3..4 ⊆ 2..5 // ⊆ is a built-in operator

// For records (product types)
{age: number, gender: string} ⊆ {age: number}

// For variants (sum types)
type Color = 'Red' | 'Green' | 'Blue' | 'Gray' | 'Brown'

type BrightColor = 'Red' | 'Green' | 'Blue'

BrightColor ⊆ Color
```
</script></section><section  data-markdown><script type="text/template">
# Polymorphisme d'inclusion

- En Scala/Java, on l'a avec le sous-typage/héritage:

```scala
class Person(val name: String, val age: Int)

class Employee(name: String, age: Int, val isManager: Boolean)
  extends Person(name, age)

val e: Employee = new Employee("John Doe", 34, true)
val p: Person = e

e.isManager == true && e.name == p.name // => true
```

<aside class="notes"><ul>
<li><p>implemented in most language with subtyping and inheritance</p>
</li>
<li><p><em>Class</em> ≈ record with functions and local variables (attributes) and automatic attributes passing</p>
</li>
<li><p>subtyping on records ≈ poor man <em>inheritance</em> (<em>Subclassing</em> in OOP)</p>
</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Polymorphisme d'inclusion

On parle de _Nominal types_ pour l'inclusion en  Scala/Java.

Avec un exemple illustratif:

```scala
// Scala: Nominal equivalence
class A(field1: String, field2: Int)

class B(field1: String, field2: Int)

new A("Hello", 1) == new B("Hello", 1) // => false
```

<aside class="notes"><ul>
<li><p>Scala use <em>nominal equivalence</em></p>
</li>
<li><p>2 equals types = they have the same structure and same name (<em>nominal types</em>)</p>
</li>
<li><p>Typescript use <em>structural equivalence</em></p>
</li>
<li><p>2 equals types = they have the same structure (<em>structural types</em>)</p>
</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Polymorphisme d'inclusion

On parle de _Structural types_ pour l'inclusion en Typescript/Ocaml/F#/Reason:

```typescript
// Typescript: Structural equivalence
type A = { field1: String, field2: number }

type B = { field1: String, field2: number }

const a: A = { field: 'Hello', field2: 1 }

const b: B = { field: 'Hello', field2: 1 }

a === b // => true
```

<aside class="notes"><ul>
<li><p>Scala use <em>nominal equivalence</em></p>
</li>
<li><p>2 equals types = they have the same structure and same name (<em>nominal types</em>)</p>
</li>
<li><p>Typescript use <em>structural equivalence</em></p>
</li>
<li><p>2 equals types = they have the same structure (<em>structural types</em>)</p>
</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Polymorphisme d'inclusion

Typage nominal & sous-typage:

```scala
// Scala
class A(f1: String, f2: Boolean)

class B(f1: String, f2: Boolean, f3: Int) extends A(f1, f2)

class C(f1: String, f2: Boolean, f3: Int)

val b: B = new B(f1 = "Hello", f2 = true, f3 = 1)
val a: A = b

val c: C = new C(f1 = "Hello", f2 = true, f3 = 1)
val a: A = c // !!!! ne compile pas, le sous-typage est explicite
```
</script></section><section  data-markdown><script type="text/template">
# Polymorphisme d'inclusion

Typage structurel & sous-typage:

```typescript
// Typescript
type A = { f1: string, f2: boolean }

type B = { f1: string, f2: boolean, f3: number }

const b: B = { f1: 'Hello', f2: true, f3: 1 }

const a: A = b // OK, le sous-typage est implicite avec les types structurels
```
</script></section><section  data-markdown><script type="text/template">
# Coercition

Sur un exemple: 

```typescript
// TS
type A = { f1: string, f2: boolean }

const a: A = { f1: 'Hello', f2: true }

const b: boolean = !a // coercition automatique au runtime 

const c: string = a.toString() // coercition manuelle
```

En Java/Scala, possible avec des casts (manuel et au runtime).

<aside class="notes"><ul>
<li><p><em>coercion</em> is a semantic conversion</p>
</li>
<li><p>statically (automatic or manual) or dynamically (runtime tests)</p>
</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Overloading

Un rappel de l'overloading:

```scala
1 + 1

1L + 1L

1.0 + 1.0
```
</script></section><section  data-markdown><script type="text/template">
# Overloading

Overloading dans un langage OO:

```scala
class Printer(state: String) {
  def printState(otherText: String): String =
    s"state: $state, otherText: $otherText"

  def printState(count: Int): String =
    s"state: $state, count: $count"
}

val printer = new Printer("Hello")

printer.printState("World")

printer.printState(1)
```

<aside class="notes"><ul>
<li><p>same name for different functions (different behaviours)</p>
</li>
<li><p>The context is used to decide which behaviour to use</p>
</li>
<li><p>could be done at compile-time or runtime</p>
</li>
<li><p>Overloading is a syntactic abbreviation</p>
</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Formes polymorphiques intermédiaires

<img 
  src="./resources/freezer-form-2.jpeg" 
  alt="logo"
  style="border: none;width: 20%;background: none;box-shadow: none;"
  />
</script></section><section  data-markdown><script type="text/template">
# Typeclass

- Introduit par Wadler & Blott in 1988: "How to make ad-hoc polymorphism less ad hoc"

- Initialement implementé en Haskell: (voir: "Typeclasses in Haskell")

- Alternative aux approaches ad-hoc des languages OO

<aside class="notes"><ul>
<li>implementation for toString, equals</li>
<li>implementation numerics ops (+, -, *)</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Typeclass

Question: Comment implémenter l'égalité de type (ex `equals` en Java) sans OO ?

```scala
1 == 1

"Hello" == "Hello"

{field1: 1, field: "hello"} == {field1: 2, field: "hello"}

"Hello" == 1 // Le compilateur doit râler
```
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Sur l'exemple de l'equalité de type:

```haskell
class Eq a where
  (==) :: a -> a -> bool
```

*Propriété*:  Le type `a` appartient à la **classe** `Eq` s'il y'a une **méthode** nommée `==` du type `a -> a -> bool` definie pour `a`

```haskell
instance Eq Int where
  (==) = eqInt
```

*Assertion*: Il y'a une fonction nommée `==` du type approprié defini sur `Int` donc `Int` appartient à la classe `Eq`
</script></section><section  data-markdown><script type="text/template">
# Typeclass

En définissant une fonction, on veut une contrainte sur `Eq`:

```haskell
-- `member` permet de savoir si un élément est dans un tableau
member :: Eq a => [a] -> a -> Bool

member [] y = False

member (x:xs) y = (x == y) || member xs y
```

- `Eq a =>` impose la contrainte que `a` appartienne à `Eq`

- la contrainte permet d'utiliser `==` dans l'implémentation

- fonction `member` a le type `[a] -> a -> Bool`.

- On allie le **generic** avec la contrainte de la typeclass.
</script></section><section  data-markdown><script type="text/template">
# Typeclass

A l'utilisation:

```haskell
member [1, 2, 3, 4] 1 -- => True

member [1, 2, 3, 4] 6 -- => False

member [True, False] True -- !!! NE COMPILE PAS
-- Pas d'instance de (Eq Bool) trouvée pour pouvoir utiliser ‘member’
```

- en appelant `member`, vérification qu'une instance pour le type `a` est définit

- si pas d'instance => erreur de compilation

- si une instance définie, alors on utilise le comportement défini pour le type
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Question: Si j'ai une instance définie pour les types `a` et `b`, est ce que je peux définir `Eq` pour la paire/tuple `(a, b)` ?
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Composition de Typeclass:

```haskell
instance Eq a, Eq b => Eq (a, b) where
  == x y = eqPair x y
```

*Propriété*: Pour chaque type `a` and `b` tel que `a` appartient à `Eq` et `b` appartient à `Eq` (pré-conditions), la paire (a, b) appartient aussi à `Eq`.

```haskell
member [(1, 2), (3, 4)] (1, 2) -- => True

member [(1, 2), (3, 4)] (5, 6) -- => False
```

On peut construire l'instance pour la pair vu qu'on a une instance pour `Int` et donc on peut appeler `member`.
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Question: Est ce que je peux définir une typeclass pour ordonner les éléments d'un type (en sachant que j'ai besoin d'égalité pour définir un ordre) ?
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Le sous-classage existe aussi avec les typeclasses:

```haskell
class Eq a => Ord a where
  (<) :: a -> a -> Bool
  (<=) :: a -> a -> Bool

instance Ord Int where
  (<)  = primLtInt
  (<=) = primLeInt
```

*Propriété*: Le type `a` appartient à `Ord` s'il y'a les operations `<` et `<=` (du bon type) définis pour `a` et si `a` appartient à `Eq`.
</script></section><section  data-markdown><script type="text/template">
# Typeclass

A l'utilisation:

```haskell
search :: (Ord a) => a -> [a] -> Bool
search x ys = not (null ys) && 
              (x == head ys || (x < head ys && search x (tail ys)))

search 1 [1, 2, 3, 4] -- => True
search 5 [1, 2, 3, 4] -- => False
```

Vu que `Ord` est un sous-type de `Eq`, on peut utiliser `==` (et toutes les méthodes de `Ord`) dans l'implémentation de `member` si `a` appartient à `Ord`.
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Comment les `typeclasses` sont-elles implémentées ?

```haskell
data EqD a = EqDict (a -> a -> Bool) -- on définit un dictionnaire pour `Eq`

getEq (EqDict e) = e -- une function sélecteur (pour extraire la méthode `==`)

eqDInt:: EqD Int -- Dictionnaire pour Int
eqDInt = EqDict eqInt
```

Les étapes à suivre:

- `EqDict (a -> a -> Bool)` définit un type dictionnaire `EqDict` qui contient une fonction

- cette fonction contient l'implémentation de `==` pour le type `a`

- La définition `Eq` pour `Int` revient à créer une instance de `EqD` (avec la bonne implém.)
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Et si on s'intéresse à l'implémentation de `member`:

```haskell
member' :: EqD a -> [a] -> a -> Bool -- `member` avec un paramètre supplémentaire pour `a`

member' eqDa [] y     = False        -- dictionnaire (passé implicitement)

member' eqDa (x:xs) y = getEq eqDa x y || member' eqDa xs y
```

Ce qui change:

- au niveau de `member`, contrainte remplacée par un paramètre supplémentaire

- nouveau paramètre = dictionnaire pour le type `a`

- paramètre supplémentaire passé implicitement par le compilateur
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Et comment ça se passe pour la composition ?

```haskell
eqDPair :: (EqD a, EqD b) -> EqD (a, b) -- composition = prendre des dictionnaires

eqDPair (eqDa, eqDb) = EqDict (eqPair (eqDa, eqDb)) -- en paramètres

eqPair (EqD a, EqD b) -> (a, b) -> (a, b) -> Bool
```

Ce qui change:

- on prend 2 paramètres supplémentaires pour les types `a` et `b`

- en d'autres termes, on a besoin de l'instance du dictionnaire pour `a` et `b`

- les 2 paramètres sont aussi passés implicitement
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Maintenant commment implemente-t-on le sous-classage ?

```haskell
data OrdD a = OrdDict (EqD a) (a -> a -> Bool) (a -> a -> Bool) --contient EqD

getEqFromOrd (OrdDict eqDa ltInt leInt) = eqDa

(<) (OrdDict eqDa ltInt leInt) = ltInt

(<=) (OrdDict eqDa ltInt leInt) = leInt

ordDInt:: OrdD Int
ordDInt = OrdDict eqDInt primLtInt primLeInt -- passe implicitement instance EqD
```

Sous le capot:

- On définit un nouveau dictionnaire `Ord`  pour `a` contenant:

  - une instance du dictionnaire `EqD` pour `a`

  - une implémentation des méthodes `<` et `<=` pour le type `a`

- En définissant l'instance d'`Ord` le dictionnaire pour `Eq` passé implicitement
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Et à l'usage c'est comme avec `Eq`:

```haskell
search :: (OrdD a) -> a -> [a] -> Bool
search ordD x ys = not (null ys) && ((==) (getEqFromOrd ordD) x (head ys) || 
              ((<) ordD x (head ys) && search ordD x (tail ys)))

search ordDInt 1 [1, 2, 3, 4] -- => True  . ordDInt est automatiquement passé
search ordDInt 5 [1, 2, 3, 4] -- => False
```
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Comment implémenterait-on une Typeclass en Scala ?
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Implementation en Scala

```scala
trait Eq[A] {
  def eq(x: A, y: A): Boolean
}
```

En s'inspirant de l'implémentation Haskell:

- Dictionnaire devient un trait et la `méthode` est une `méthode` =)

- Le paramètre de type reste un paramètre de type (`generic`)
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Par contre comment avoir le passage de paramètre implicite ?

- scala définit le mot-clé `implicit` pour le passage implicit de paramètre

- `member` prendrait un paramètre (implicite) de type `Eq[A]`

```scala
def member[A](ls: List[A], y: A)(implicit eqA: Eq[A]): Boolean = ls match {
  case Nil => false
  case head :: tail => eqA.eq(head, y) || member(tail, y)
}
```
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Définition des instances:

```scala
implicit object EqInt extends Eq[Int] {
  def eq(x: Int, y: Int): Boolean = ???
}

implicit def EqPair[A, B](implicit eqA: Eq[A], eqB: Eq[B]): Eq[(A, B)] =
  new Eq[(A, B)] {
    def eq(x: (A, B), y: (A, B)): Boolean = ???
  }
```

- on définit les instances comme des valeurs implicites

- le compilateur passe les instances automatiquement

- pour une paire, on a une fonction `EqPair`

- `EqPair` prend de manière implicite les instances pour les types `A` et `B`
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Typeclass et sous-classage en Scala:

```scala
trait Order[A] extends Eq[A] {
  def lt(x: A, y: A): Boolean
  def ltEq(x: A, y: A): Boolean
}

implicit object OrdInt extends Order[Int] {
  def lt(x: A, y: A): Boolean = ???
  def ltEq(x: A, y: A): Boolean = ???
}

def search[A](x: A, list: List[A])(implicit ordA: Order[A]): Boolean = 
  list match {
    case Nil => false
    case head :: tail => (ordA.eq(x, head) || (ordA.lt(x, tail) && search(x, tail)))
  }
```

Relation de sous-classage entre `Ord` et `Eq` modélisée par héritage (de `trait`).
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Comment fonctionnent les `implicit`s en Scala ?

Où le compilateur va-t-il les chercher ?

Que se passe-t-il si j'en ai plusieurs de défini ?
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Comment fonctionnent les `implicit`s en Scala ?
- Une méthode peut avoir une liste de paramètres implicites, marquée par le mot clé `implicit` au début de la liste de paramètres.
- la liste de paramètres implicits définie après les groupes de paramètres ordinaires
- Si les paramètres de cette liste de paramètres ne sont pas passés comme d'habitude, Scala cherchera s'il peut obtenir une valeur implicite du type correct et, s'il le peut, la transmet automatiquement.

```scala
def f(a: Int)(implicit b: String) = ???

implicit val str: String = "Hello"

f(a = 1)(b = "Hello")

f(a = 1)
```
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Où le compilateur va-t-il les chercher ?
De manière simplifiée (pour les typeclass), on recherche à plusieurs endroits:
- **d'abord dans le scope dans lequel on définit la fonction**

```scala
def f(a: Int)(implicit b: String) = ???

implicit val str: String = "Hello"

f(a = 1)
```

La variable `str` va être sélectionné par le compilateur et va être passé implicitement
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Où le compilateur va-t-il les chercher ?
De manière simplifiée (pour les typeclass), on recherche à plusieurs endroits:
- **d'abord dans le scope dans lequel on définit la fonction** (il peut aussi s'agir d'un import)

```scala
import unPackage.str

def f(a: Int)(implicit b: String) = ???

f(a = 1)
```

La variable `str` va être trouvée par le compilateur et va être passé implicitement
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Où le compilateur va-t-il les chercher ?
De manière simplifiée (pour les typeclass), on recherche à plusieurs endroits:
- si pas de vairable dans le scope de la fonction
- **on recherche dans le companion de la typeclass**

Par ex, dans `Typeclass.scala`:

```scala
trait Typeclass[A] {
  def method: Unit
}

object Typeclass {
  implicit val str: Typeclass[String] = new Typeclass {}
}
```
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Où le compilateur va-t-il les chercher ?
De manière simplifiée (pour les typeclass), on recherche à plusieurs endroits:
- si pas de vairable dans le scope de la fonction
- **on recherche dans le companion de la typeclass**

Dans le fichier dans lequel on définit la fonction:

```scala
import xxx.Typeclass

object Test {
  def f[A](a: Int)(implicit t: Typeclass[A]) = ???

  f[String](a = 1)
}
```

La variable `str` va être trouvée par le compilateur et va être passé implicitement
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Où le compilateur va-t-il les chercher ?
De manière simplifiée (pour les typeclass), on recherche à plusieurs endroits:
- si pas de vairable dans le scope de la fonction
- si pas de variable dans le companion de la typeclass
- **on recherche dans une super classe du companion**

Dans `Typeclass.scala`:
```scala
import xxx.Typeclass

trait Typeclass[A] {
  def method: Unit
}

trait Parent {
  def f[A](a: Int)(implicit t: Typeclass[A]) = ???
}

object Typeclass extends Parent {}
```
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Où le compilateur va-t-il les chercher ?
De manière simplifiée (pour les typeclass), on recherche à plusieurs endroits:
- si pas de vairable dans le scope de la fonction
- si pas de variable dans le companion de la typeclass
- **on recherche dans une super classe du companion**

Dans le fichier dans lequel on définit la fonction:

```scala
import xxx.Typeclass

object Test {
  def f[A](a: Int)(implicit t: Typeclass[A]) = ???

  f[String](a = 1)
}
```

La variable `str` va être trouvée par le compilateur et va être passée implicitement.
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Que se passe-t-il si j'en ai plusieurs de défini ?
- Deux variables implicites de même type dans la même portée provoquent une erreur de compilation, à la première utilisation

```scala
def f[A](a: Int)(implicit t: Typeclass[A]) = ???

implicit val str1: Typeclass[String] = ???

implicit val str2: Typeclass[String] = ???

f[String](a = 1) // Erreur du compilateur
```

Dans ce cas, le compilateur ne sait pas laquelle méthode choisir, il lance une erreur de compilation.
</script></section><section  data-markdown><script type="text/template">
# Typeclass

Et si on utilisait les `typeclass` pour la coercition ?

```haskell
-- haskell
class Coerce a b where
  coerce :: a -> b

instance Coerce Int String where
  coerce = convertIntToString
```

```scala
// Scala
trait Coerce[A, B] {
  def coerce: A => B
}

implicit object IntToStringCoerce extends Coerce[Int, String] {
  def coerce: Int => String = convertIntToString
}
```

<aside class="notes"><ul>
<li>Talk about implicit conversions in Scala (coercion)</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Typeclass

Et si on utilisait pas les `typeclass` pour la coercition ?
On peut imaginer des conversions implicites:

```scala
implicit def convertIntToString(i: Int): String = i.toString

val a: String = 123
```

Scala s'attend à mettre un `String` dans `a` donc il recherche une conversion implicite dans le scope pour transformer `123` en `String`, s'il n'en trouve pas une erreur de compilation est levée.
</script></section><section  data-markdown><script type="text/template">
# Valeurs polymorphiques

- De la définition du polymorphisme: "une valeur peut avoir plus d'un type"

```haskell
id :: a -> a -- fonction identité
id = \a -> a -- id est une valeur (une fonction est une valeur)

id2 :: forall a. a -> a -- equivalent à la définition de `id`
id2 = id                -- donc on peut ré-utiliser la valeur précédente

:t id  -- => id  :: a -> a
```
</script></section><section  data-markdown><script type="text/template">
# Valeurs polymorphiques

- De la définition du polymorphisme: "une valeur peut avoir plus d'un type"

```haskell
idInt:: Int -> Int; idInt = id

idDouble:: Double -> Double; idDouble = id
```

- `id` est une valeur appartenant à plusieurs types (`Int -> Int`, `Double -> Double`, ...)

- donc `id` est une `valeur polymorphique` (la valeur dépend d'un paramètre de type)

- donc son type est: `forall a. a -> a` (oui, c'est un type)
</script></section><section  data-markdown><script type="text/template">
# Valeurs polymorphiques

Supporté en Typescript:

```typescript
// TS
const id: <A> (value: A) => A = <A>(value: A) => value 

const idInt: (value: number) => number = id
const idStr: (value: String) => String = id
```

<aside class="notes"><ul>
<li><p>polymorphic expressions (values, functions) as 1st class citizen in TS, Haskell: one code is generated and executed</p>
</li>
<li><p>polymorphic expressions (values, functions) as Znd class citizen in Scala: <code>generics</code> but monomorphic values</p>
</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Valeurs polymorphiques

Mais pas supporté en Scala 2 (mais arrive en Scala 3):

```scala
// Scala
def id[A]: A => A = value => value

def idInt: Int => Int = id

val id2 = id // => id2: Nothing => Nothing = $$Lambda$1103/1821370276@2047981
:t id        // => id:  Nothing => Nothing
// Pas possible en Scala 2, mais sera disponible en Scala 3
```

<aside class="notes"><ul>
<li><p>polymorphic expressions (values, functions) as 1st class citizen in TS, Haskell: one code is generated and executed</p>
</li>
<li><p>polymorphic expressions (values, functions) as Znd class citizen in Scala: <code>generics</code> but monomorphic values</p>
</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Polymorphisme d'ordre supérieur

Exemple illustratif:

```haskell
twice :: (forall a. a -> a) -> b -> b -- la fonction f est une valeur polymorphique
twice f b = f (f b)                   -- ce qui nous permet de lui appliquer la valeur `b`
twice id 3 -- => 3
```
- `twice` prend en paramètre une valeur polymorphique (`f`)
- `twice` est rank-2 polymorphique (id étant rank-1)
- N (rank) = niveau d'imbrication de la valeur polymorphique.

```haskell
rank3 :: ((forall a. a -> a) -> c -> c) -> c -> c -- rank-3
rank3 f1 c = f1(id)(c)
```
- `rank3` est rank-3 polymorphique.
</script></section><section  data-markdown><script type="text/template">
# Polymorphisme d'ordre supérieur

Quelques points d'attention à avoir:

```haskell
succ :: Int -> Int
succ a = a + 1

twice2 :: (a -> a) -> a -> a
twice2 f a = f (f a)

twice2 id 3 -- => 3
twice2 succ 3 -- => 5

twice succ 3 -- !!!! Ne compile pas
```
</script></section><section  data-markdown><script type="text/template">
# Formes polymorphiques avancées

<img 
  src="resources/freezer-form-4.png" 
  alt="logo"
  style="border: none;width: 20%;background: none;box-shadow: none;"
  />
</script></section><section  data-markdown><script type="text/template">
# Types existentiels 101

- types paramétriques <=> quantificateur universel en logique (`forall` <=> `∀`)

- `p: ∀ a. T(a)` ≈ "pour tout type `a`, `p` est de type `T(a)`"

- càd le type `a` est inconnu lors de l'implémentation mais connu à l'appel


Quizz: Est ce que vous connaissez un autre symbole utilisé en logique ?
</script></section><section  data-markdown><script type="text/template">
# Types existential 101

- Nous avons également un autre quantificateur: `∃`

- Mais comment pourrait-on interprété cela avec les types:

- `p: ∃ a. T(a)` ≈ "il existe un type `a` pour lequel `p` est de type `T(a)`"

- càd le type `a` est inconnu à l'appel mais connu à l'implémentation
</script></section><section  data-markdown><script type="text/template">
# Types existentiels 101

- valeurs ordinaires peuvent être vus comme des types quantifiés:
  - `(3, 4): ∃a. (a, a)` avec `a = Int`
  - `(3, 4): ∃a. a`      avec `a = (Int, Int)`

- Les bornes du système de type aussi:
  - `Any` (top type)         ≈ `∃ a. a`
  - `Nothing` (bottom type)  ≈ `∀ a. a`

- Exemples contre-intuitifs (`∈` pour **est du type**):

```haskell
(3, 4), (3, true) ∈ ∃ a. (a, a) -- a = Int & a = Any resp.
(3, succ), ([1, 2], length) ∈ ∃ a. (a, a -> Int) -- a = Int & a = List[Int] resp.
(3, length) ∉ ∃ a. (a, a -> Int) -- even with a = Any
```
</script></section><section  data-markdown><script type="text/template">
# Types existentiels 101

- Le but en utilisant des existentiels: *Cacher de l'information*

- `∃ a. (a, a -> Int)`: type abstrait packagé avec des opérations

- type abstrait => on cache la façon dont le type est représenté

- Sur un exemple:
  - avec un record: `type T = ∃ a. {value: a, op: a -> Int}`
  - pour déclarer une valeur: `x: T = {value: 3, op: succ}` (`a = Int`)
  - à l'usage: `x.op(x.value)`

<aside class="notes"><ul>
<li><p>packaged object <code>x</code> is an <em>abstract module</em> (or <em>package</em>)</p>
</li>
<li><p><code>T</code> is module <em>interface</em> and value <code>x</code> is its content</p>
</li>
<li><p>binding <code>a = Int</code> is its representation</p>
</li>
<li><p>type <code>a</code> is known when defining <code>x</code> (i.e. implementation)</p>
</li>
<li><p>type <code>a</code> is unknown when we will use <code>x</code> (outside)</p>
</li>
<li><p>no assumptions could be made on <code>a</code> (unless using <code>value</code> and <code>op</code>)</p>
</li>
<li><p>existential quantifier ≈ 2nd order information hiding (typelevel)</p>
</li>
<li><p>value scoping ≈ 1st order information hiding (i.e. local variable)</p>
</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Types existentiels 101

```haskell
-- Haskell: avec l'extension ExistentialQuantification
data Ex = forall a. Ex (a, a -> Int)

ex = Ex (3, succ)
```

On a un paramètre de type mais il est encapsulé par `Ex` (il n'apparaît qu'à droite de l'égalité).

Un type existential est un `generic` est un type qui est caché.

<aside class="notes"><ul>
<li>Existential with generics since Java 5 (Odersky)</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Types existentiels 101

On a des types existentiels en Java / Scala:

```scala
val list: List[_] = List(1, 2, 3, 4)
// list: List[_] = List(1, 2, 3, 4)

list.head
// res1: Any = 1

list.length == 4 // => true
```

<aside class="notes"><ul>
<li>Existential with generics since Java 5 (Odersky)</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Types existentiels 101

Scala: on peut l'émuler avec des types abstraits

```scala
trait Ex1 {
  type A
  val value: A
  def op: A => Int
}

val ex1: Ex1 = new Ex1 {
  type A = Int
  val value = 3
  def op = succ
}

val t: Int = ex1.value //  error: type mismatch; found : ex.A; required: Int
```

<aside class="notes"><ul>
<li>overlap with dependent typing</li>
<li>GADTs consumption via pattern-matching, or fold</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Types existentiels 101

Scala: on peut aussi l'émuler avec des `sealed trait` et `case class`

```scala
sealed trait Ex2

case class Ex2Impl[A](value: A, op: A => Int) extends Ex2

val ex2: Ex2 = Ex2Impl(3, succ)

val t: Int = ex2.value // error: value value is not a member of Ex2
```

<aside class="notes"><ul>
<li>overlap with dependent typing</li>
<li>GADTs consumption via pattern-matching, or fold</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
# Types existentiels 101

Mixons les quantificateurs universels and existentiels avec un exemple sur les piles:
- pile generique parametrée par un type (universel)
- abstraction sur la façon dont on représente les données (existentiel)

```scala
trait GenericStack[Item] {
  type Stack
  def emptyStack: Stack
  def push: (Item, Stack) => Stack
  def pop: Stack => Stack
  def top: Stack => Item
}

// Builder nécessaire parce que Scala n'a pas de valeurs polymorphiques
trait StackBuilder {
  def apply[A]: GenericStack[A]
}
```
</script></section><section  data-markdown><script type="text/template">
# Types existentiels 101

```scala
val getListStack = new StackBuilder { 
  def apply[Item]: GenericStack[Item] = new GenericStack[Item] {
    type Stack = List[Item]

    def emptyStack: Stack = List.empty

    def push: (Item, Stack) => Stack = (item, list) => item :: list

    def pop: Stack => Stack = stack => stack.tail

    def top: Stack => Item = stack => stack.head
  }
}
```
</script></section><section  data-markdown><script type="text/template">
# Types existentiels 101

```scala
val getVectorStack = new StackBuilder {
  def apply[Item]: GenericStack[Item] = new GenericStack[Item] {
    type Stack = Vector[Item]

    def emptyStack: Stack = Vector.empty

    def push: (Item, Stack) => Stack = (item, list) => item +: list

    def pop: Stack => Stack = stack => stack.tail

    def top: Stack => Item = stack => stack.head
    ...
  }
}
```
</script></section><section  data-markdown><script type="text/template">
# Types existentiels 101

```scala
def useStack(getStack: StackBuilder) = {
  val stack = getStack[Int]
  stack.top(stack.push(3, stack.emptyStack))
}

useStack(getListStack)
// res11: Int = 3
useStack(getVectorStack)
// res12: Int = 3
```
</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-background="#27457b" -->
# Quantification bornée

<img 
  src="./resources/freezer-form-5.png" 
  alt="logo"
  style="border: none;width: 20%;background: none;box-shadow: none;"
  />
</script></section><section  data-markdown><script type="text/template">
# ∀ and sous-typage

Mixer polymorphisme paramétrique et le sous-typage peut-être utile:

```typescript
const f = (x: {one: number}) => x.one

f({one: 1}) === f({one: 1, two: true}) === 1

f({one: true}) // Type 'true' is not assignable to type 'number'.(2322)
```
</script></section><section  data-markdown><script type="text/template">
# ∀ and sous-typage

On peut faire mieux, on peut être générique sur les sous-types en définissant une borne supérieure

```typescript
const h = <A extends {one: number}>(x: A) => x.one

h({ one: 1 }) === h({ one: 1, two: true }) === 1

h({one: true}) // Type 'true' is not assignable to type 'number'.(2322)
```

Quelle est la différence entre `f` et `h` ?
- avec `f` la relation d'inclusion est **implicite**
- avec `h` la relation d'inclusion est **explicite**

Notons que: `∀ a. T` <=> `∀ a ≤ any. T`
</script></section><section  data-markdown><script type="text/template">
# ∀ and sous-typage

Sur un autre exemple:

```typescript
type Point = {x: number, y: number}
type Tile = {x: number, y: number, hor: number, ver: number}

const moveX0 = (p: Point, dx: number) => {
  p.x = p.x + dx
  return p
}

moveX0({x: 1, y: 1}, 1).x === 2

moveX0({ x: 1, y: 1, hor: 2, ver: 2 }, 1).hor 
// => Property 'hor' does not exist on type 'Point'.(2339)
```

- En passant un argument de type `Tile` à `moveX0` on l'upcaste en `Point`

- Du coup on perd les attributs propres (infos de type) de `Tile`
</script></section><section  data-markdown><script type="text/template">
# ∀ and sous-typage

Si on l'implémente différemment:

```typescript
type Point = {x: number, y: number}
type Tile = {x: number, y: number, hor: number, ver: number}

const moveX  = <P extends Point> (p: P, dx: number) => { 
  p.x = p.x + dx
  return p
}

moveX({x: 1, y: 1}, 1).x === 2

moveX({ x: 1, y: 1, hor: 2, ver: 2 }, 1).hor === 2
```

- En passant un argument de type `Tile` à `moveX0` il garde son type

- Du coup on ne plus perd les infos de type de `Tile`
</script></section><section  data-markdown><script type="text/template">
# ∀ and sous-typage

A noter:

- `Point` ≈ `∃ a ≤ Point. a` 

- ∀ and Subtyping => F-bound polymorphism (supporté par Java / Scala)
</script></section><section  data-markdown><script type="text/template">
# ∃ & abstraction partielle

- Mix types existentiels et sous-typage: `∃ a ≤ T1. T2(a)`

- On exprime ici des **types partiallement abstraits**

- Autrement dit, `A` est abstrait & c'est un sous-type de `B`

- permet d'exprimer une relation de sous-typage entre 2 types

- `∃ a. T(a)` <=> `∃ a ≤ any. T(a)`
</script></section><section  data-markdown><script type="text/template">
# ∃ & abstraction partielle

Sur un exemple:

```scala
type Point = ???
type Tile = ???
```

- `Tile` est un sous-type de `Point`, mais la hiérarchie est inconnue

- Mais on veut créer un moodule qui va les manipuler

```scala
trait TileModule {
  type P
  type T <: P

  def buildTile(x: Int, y: Int, hor: Int, ver: Int): T
  def origin: T => P
  def hor: T => Int
  def ver: T => Int
}
```
</script></section><section  data-markdown><script type="text/template">
# ∃ & abstraction partielle

Pour celui qui implémente la hiérarchie:

```scala
class Point(val x: Int, val y: Int)
class Segment(x: Int, y: Int, val hor: Int) extends Point(x, y)
class Tile(x: Int, y: Int, hor: Int, val ver: Int) extends Segment(x, y, hor)

class TileModuleImpl extends TileModule {
  type P = Point
  type T = Tile

  def buildTile(x: Int, y: Int, hor: Int, ver: Int): Tile =
    new Tile(x, y, hor, ver)

  def origin: T => P = tile => tile
  def hor: T => Int = _.hor
  def ver: T => Int = _.ver
}
```
</script></section><section  data-markdown><script type="text/template">
# ∃ & abstraction partielle

Pour celui qui utilise la module:

```scala
def calc(tileModule: TileModule): Int = {
  val tile = tileModule.buildTile(0, 0, 1, 1)
  val hor = tileModule.hor(tile)
  val ver = tileModule.ver(tile)
  hor + ver
}

calc(new TileModuleImpl)
// res14: Int = 2
```
</script></section><section  data-markdown><script type="text/template">
# Fin

## Des questions ?
</script></section></div>
        </div>

        <script src="./lib/js/head.min.js"></script>
        <script src="./js/reveal.js"></script>

        <script>
            function extend() {
              var target = {};
              for (var i = 0; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (source.hasOwnProperty(key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            }

            // Optional libraries used to extend on reveal.js
            var deps = [
              { src: './lib/js/classList.js', condition: function() { return !document.body.classList; } },
              { src: './plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: './plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
              { src: './plugin/zoom-js/zoom.js', async: true },
              { src: './plugin/notes/notes.js', async: true },
              { src: './plugin/math/math.js', async: true }
            ];

            // default options to init reveal.js
            var defaultOptions = {
              controls: true,
              progress: true,
              history: true,
              center: true,
              transition: 'default', // none/fade/slide/convex/concave/zoom
              dependencies: deps
            };

            // options from URL query string
            var queryOptions = Reveal.getQueryHash() || {};

            var options = {"transition":"fade","slideNumber":"c/t","width":1920,"height":1080,"margin":0.08,"minScale":0.2,"maxScale":1.5};
            options = extend(defaultOptions, options, queryOptions);
        </script>


        <script>
          Reveal.initialize(options);
        </script>
    </body>
</html>
